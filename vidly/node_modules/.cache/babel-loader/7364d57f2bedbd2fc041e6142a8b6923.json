{"ast":null,"code":"import { useLayoutEffect } from 'react-layout-effect';\nimport { eachProp, is, toArray, isAnimatedString, Globals, getFluidValue, each, raf, flush, FluidValue, deprecateInterpolate, callFluidObservers, frameLoop, hasFluidValue, flushCalls, isEqual, getFluidObservers, addFluidObserver, removeFluidObserver, noop, useMemoOne, useForceUpdate, usePrev, useOnce, createInterpolator, createStringInterpolator } from '@react-spring/shared';\nexport { Globals, createInterpolator } from '@react-spring/shared';\nimport { useContext, createElement, createContext, useMemo, useRef, useState, Fragment } from 'react';\nimport { getAnimated, AnimatedValue, getPayload, AnimatedString, getAnimatedType, setAnimated } from '@react-spring/animated';\nexport * from '@react-spring/types/animated';\nexport * from '@react-spring/types/interpolation';\n\nfunction callProp(value, ...args) {\n  return is.fun(value) ? value(...args) : value;\n}\n\nconst matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\n\nconst resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;\n\nconst getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;\n\nconst noopTransform = value => value;\n\nconst getDefaultProps = (props, transform = noopTransform) => {\n  let keys = DEFAULT_PROPS;\n\n  if (props.default && props.default !== true) {\n    props = props.default;\n    keys = Object.keys(props);\n  }\n\n  const defaults = {};\n\n  for (const key of keys) {\n    const value = transform(props[key], key);\n\n    if (!is.und(value)) {\n      defaults[key] = value;\n    }\n  }\n\n  return defaults;\n};\n\nconst DEFAULT_PROPS = [\"config\", \"onProps\", \"onStart\", \"onChange\", \"onPause\", \"onResume\", \"onRest\"];\nconst RESERVED_PROPS = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onPause: 1,\n  onResume: 1,\n  onRest: 1,\n  onResolve: 1,\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  onDestroyed: 1,\n  keys: 1,\n  callId: 1,\n  parentId: 1\n};\n\nfunction getForwardProps(props) {\n  const forward = {};\n  let count = 0;\n  eachProp(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n      count++;\n    }\n  });\n\n  if (count) {\n    return forward;\n  }\n}\n\nfunction inferTo(props) {\n  const to = getForwardProps(props);\n\n  if (to) {\n    const out = {\n      to\n    };\n    eachProp(props, (val, key) => key in to || (out[key] = val));\n    return out;\n  }\n\n  return { ...props\n  };\n}\n\nfunction computeGoal(value) {\n  value = getFluidValue(value);\n  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? Globals.createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n\nfunction hasProps(props) {\n  for (const _ in props) return true;\n\n  return false;\n}\n\nfunction isAsyncTo(to) {\n  return is.fun(to) || is.arr(to) && is.obj(to[0]);\n}\n\nfunction detachRefs(ctrl, ref) {\n  var _a;\n\n  (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);\n  ref == null ? void 0 : ref.delete(ctrl);\n}\n\nfunction replaceRef(ctrl, ref) {\n  var _a;\n\n  if (ref && ctrl.ref !== ref) {\n    (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);\n    ref.add(ctrl);\n    ctrl.ref = ref;\n  }\n}\n\nfunction useChain(refs, timeSteps, timeFrame = 1e3) {\n  useLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      each(refs, (ref, i) => {\n        const controllers = ref.current;\n\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i];\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          each(controllers, ctrl => {\n            each(ctrl.queue, props => {\n              props.delay = key => delay + callProp(props.delay || 0, key);\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      each(refs, ref => {\n        const controllers = ref.current;\n\n        if (controllers.length) {\n          const queues = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          });\n          p = p.then(() => {\n            each(controllers, (ctrl, i) => each(queues[i] || [], update => ctrl.queue.push(update)));\n            return ref.start();\n          });\n        }\n      });\n    }\n  });\n}\n\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nconst linear = t => t;\n\nconst defaults = { ...config.default,\n  mass: 1,\n  damping: 1,\n  easing: linear,\n  clamp: false\n};\n\nclass AnimationConfig {\n  constructor() {\n    this.velocity = 0;\n    Object.assign(this, defaults);\n  }\n\n}\n\nfunction mergeConfig(config, newConfig, defaultConfig) {\n  if (defaultConfig) {\n    defaultConfig = { ...defaultConfig\n    };\n    sanitizeConfig(defaultConfig, newConfig);\n    newConfig = { ...defaultConfig,\n      ...newConfig\n    };\n  }\n\n  sanitizeConfig(config, newConfig);\n  Object.assign(config, newConfig);\n\n  for (const key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key];\n    }\n  }\n\n  let {\n    mass,\n    frequency,\n    damping\n  } = config;\n\n  if (!is.und(frequency)) {\n    if (frequency < 0.01) frequency = 0.01;\n    if (damping < 0) damping = 0;\n    config.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\n    config.friction = 4 * Math.PI * damping * mass / frequency;\n  }\n\n  return config;\n}\n\nfunction sanitizeConfig(config, props) {\n  if (!is.und(props.decay)) {\n    config.duration = void 0;\n  } else {\n    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);\n\n    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {\n      config.duration = void 0;\n      config.decay = void 0;\n    }\n\n    if (isTensionConfig) {\n      config.frequency = void 0;\n    }\n  }\n}\n\nconst emptyArray = [];\n\nclass Animation {\n  constructor() {\n    this.changed = false;\n    this.values = emptyArray;\n    this.toValues = null;\n    this.fromValues = emptyArray;\n    this.config = new AnimationConfig();\n    this.immediate = false;\n  }\n\n}\n\nfunction scheduleProps(callId, {\n  key,\n  props,\n  defaultProps,\n  state,\n  actions\n}) {\n  return new Promise((resolve, reject) => {\n    var _a;\n\n    let delay;\n    let timeout;\n    let cancel = matchProp((_a = props.cancel) != null ? _a : defaultProps == null ? void 0 : defaultProps.cancel, key);\n\n    if (cancel) {\n      onStart();\n    } else {\n      if (!is.und(props.pause)) {\n        state.paused = matchProp(props.pause, key);\n      }\n\n      let pause = defaultProps == null ? void 0 : defaultProps.pause;\n\n      if (pause !== true) {\n        pause = state.paused || matchProp(pause, key);\n      }\n\n      delay = callProp(props.delay || 0, key);\n\n      if (pause) {\n        state.resumeQueue.add(onResume);\n        actions.pause();\n      } else {\n        actions.resume();\n        onResume();\n      }\n    }\n\n    function onPause() {\n      state.resumeQueue.add(onResume);\n      state.timeouts.delete(timeout);\n      timeout.cancel();\n      delay = timeout.time - raf.now();\n    }\n\n    function onResume() {\n      if (delay > 0) {\n        timeout = raf.setTimeout(onStart, delay);\n        state.pauseQueue.add(onPause);\n        state.timeouts.add(timeout);\n      } else {\n        onStart();\n      }\n    }\n\n    function onStart() {\n      state.pauseQueue.delete(onPause);\n      state.timeouts.delete(timeout);\n\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true;\n      }\n\n      try {\n        actions.start({ ...props,\n          callId,\n          cancel\n        }, resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n\nconst getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some(result => result.cancelled) ? getCancelledResult(target) : results.every(result => result.noop) ? getNoopResult(target) : getFinishedResult(target, results.every(result => result.finished));\n\nconst getNoopResult = (target, value = target.get()) => ({\n  value,\n  noop: true,\n  finished: true,\n  target\n});\n\nconst getFinishedResult = (target, finished, value = target.get()) => ({\n  value,\n  finished,\n  target\n});\n\nconst getCancelledResult = (target, value = target.get()) => ({\n  value,\n  cancelled: true,\n  target\n});\n\nfunction runAsync(to, props, state, target) {\n  const {\n    callId,\n    parentId,\n    onRest\n  } = props;\n  const {\n    asyncTo: prevTo,\n    promise: prevPromise\n  } = state;\n\n  if (!parentId && to === prevTo && !props.reset) {\n    return prevPromise;\n  }\n\n  return state.promise = (async () => {\n    state.asyncId = callId;\n    state.asyncTo = to;\n    const defaultProps = getDefaultProps(props, (value, key) => key === \"onRest\" ? void 0 : value);\n    let preventBail;\n    let bail;\n    const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));\n\n    const bailIfEnded = bailSignal => {\n      const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);\n\n      if (bailResult) {\n        bailSignal.result = bailResult;\n        bail(bailSignal);\n        throw bailSignal;\n      }\n    };\n\n    const animate = (arg1, arg2) => {\n      const bailSignal = new BailSignal();\n      return (async () => {\n        bailIfEnded(bailSignal);\n        const props2 = is.obj(arg1) ? { ...arg1\n        } : { ...arg2,\n          to: arg1\n        };\n        props2.parentId = callId;\n        eachProp(defaultProps, (value, key) => {\n          if (is.und(props2[key])) {\n            props2[key] = value;\n          }\n        });\n        const result2 = await target.start(props2);\n        bailIfEnded(bailSignal);\n\n        if (state.paused) {\n          await new Promise(resume => {\n            state.resumeQueue.add(resume);\n          });\n        }\n\n        return result2;\n      })();\n    };\n\n    let result;\n\n    try {\n      let animating;\n\n      if (is.arr(to)) {\n        animating = (async queue => {\n          for (const props2 of queue) {\n            await animate(props2);\n          }\n        })(to);\n      } else {\n        animating = Promise.resolve(to(animate, target.stop.bind(target)));\n      }\n\n      await Promise.all([animating.then(preventBail), bailPromise]);\n      result = getFinishedResult(target, true);\n    } catch (err) {\n      if (err instanceof BailSignal) {\n        result = err.result;\n      } else {\n        throw err;\n      }\n    } finally {\n      if (callId == state.asyncId) {\n        state.asyncId = parentId;\n        state.asyncTo = parentId ? prevTo : void 0;\n        state.promise = parentId ? prevPromise : void 0;\n      }\n    }\n\n    if (is.fun(onRest)) {\n      raf.batchedUpdates(() => {\n        onRest(result);\n      });\n    }\n\n    return result;\n  })();\n}\n\nfunction stopAsync(state, cancelId) {\n  flush(state.timeouts, t => t.cancel());\n  state.pauseQueue.clear();\n  state.resumeQueue.clear();\n  state.asyncId = state.asyncTo = state.promise = void 0;\n  if (cancelId) state.cancelId = cancelId;\n}\n\nclass BailSignal extends Error {\n  constructor() {\n    super(\"An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.\");\n  }\n\n}\n\nconst isFrameValue = value => value instanceof FrameValue;\n\nlet nextId = 1;\n\nclass FrameValue extends FluidValue {\n  constructor() {\n    super(...arguments);\n    this.id = nextId++;\n    this._priority = 0;\n  }\n\n  get priority() {\n    return this._priority;\n  }\n\n  set priority(priority) {\n    if (this._priority != priority) {\n      this._priority = priority;\n\n      this._onPriorityChange(priority);\n    }\n  }\n\n  get() {\n    const node = getAnimated(this);\n    return node && node.getValue();\n  }\n\n  to(...args) {\n    return Globals.to(this, args);\n  }\n\n  interpolate(...args) {\n    deprecateInterpolate();\n    return Globals.to(this, args);\n  }\n\n  toJSON() {\n    return this.get();\n  }\n\n  observerAdded(count) {\n    if (count == 1) this._attach();\n  }\n\n  observerRemoved(count) {\n    if (count == 0) this._detach();\n  }\n\n  _attach() {}\n\n  _detach() {}\n\n  _onChange(value, idle = false) {\n    callFluidObservers(this, {\n      type: \"change\",\n      parent: this,\n      value,\n      idle\n    });\n  }\n\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      frameLoop.sort(this);\n    }\n\n    callFluidObservers(this, {\n      type: \"priority\",\n      parent: this,\n      priority\n    });\n  }\n\n}\n\nconst $P = Symbol.for(\"SpringPhase\");\nconst HAS_ANIMATED = 1;\nconst IS_ANIMATING = 2;\nconst IS_PAUSED = 4;\n\nconst hasAnimated = target => (target[$P] & HAS_ANIMATED) > 0;\n\nconst isAnimating = target => (target[$P] & IS_ANIMATING) > 0;\n\nconst isPaused = target => (target[$P] & IS_PAUSED) > 0;\n\nconst setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;\n\nconst setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;\n\nclass SpringValue extends FrameValue {\n  constructor(arg1, arg2) {\n    super();\n    this.animation = new Animation();\n    this.defaultProps = {};\n    this._state = {\n      paused: false,\n      pauseQueue: new Set(),\n      resumeQueue: new Set(),\n      timeouts: new Set()\n    };\n    this._pendingCalls = new Set();\n    this._lastCallId = 0;\n    this._lastToId = 0;\n\n    if (!is.und(arg1) || !is.und(arg2)) {\n      const props = is.obj(arg1) ? { ...arg1\n      } : { ...arg2,\n        from: arg1\n      };\n\n      if (is.und(props.default)) {\n        props.default = true;\n      }\n\n      this.start(props);\n    }\n  }\n\n  get idle() {\n    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);\n  }\n\n  get goal() {\n    return getFluidValue(this.animation.to);\n  }\n\n  get velocity() {\n    const node = getAnimated(this);\n    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map(node2 => node2.lastVelocity || 0);\n  }\n\n  get hasAnimated() {\n    return hasAnimated(this);\n  }\n\n  get isAnimating() {\n    return isAnimating(this);\n  }\n\n  get isPaused() {\n    return isPaused(this);\n  }\n\n  advance(dt) {\n    let idle = true;\n    let changed = false;\n    const anim = this.animation;\n    let {\n      config,\n      toValues\n    } = anim;\n    const payload = getPayload(anim.to);\n\n    if (!payload && hasFluidValue(anim.to)) {\n      toValues = toArray(getFluidValue(anim.to));\n    }\n\n    anim.values.forEach((node2, i) => {\n      if (node2.done) return;\n      const to = node2.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i];\n      let finished = anim.immediate;\n      let position = to;\n\n      if (!finished) {\n        position = node2.lastPosition;\n\n        if (config.tension <= 0) {\n          node2.done = true;\n          return;\n        }\n\n        const elapsed = node2.elapsedTime += dt;\n        const from = anim.fromValues[i];\n        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n        let velocity;\n\n        if (!is.und(config.duration)) {\n          let p = 1;\n\n          if (config.duration > 0) {\n            p = (config.progress || 0) + elapsed / config.duration;\n            p = p > 1 ? 1 : p < 0 ? 0 : p;\n          }\n\n          position = from + config.easing(p) * (to - from);\n          velocity = (position - node2.lastPosition) / dt;\n          finished = p == 1;\n        } else if (config.decay) {\n          const decay = config.decay === true ? 0.998 : config.decay;\n          const e = Math.exp(-(1 - decay) * elapsed);\n          position = from + v0 / (1 - decay) * (1 - e);\n          finished = Math.abs(node2.lastPosition - position) < 0.1;\n          velocity = v0 * e;\n        } else {\n          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;\n          const precision = config.precision || (from == to ? 5e-3 : Math.min(1, Math.abs(to - from) * 1e-3));\n          const restVelocity = config.restVelocity || precision / 10;\n          const bounceFactor = config.clamp ? 0 : config.bounce;\n          const canBounce = !is.und(bounceFactor);\n          const isGrowing = from == to ? node2.v0 > 0 : from < to;\n          let isMoving;\n          let isBouncing = false;\n          const step = 1;\n          const numSteps = Math.ceil(dt / step);\n\n          for (let n = 0; n < numSteps; ++n) {\n            isMoving = Math.abs(velocity) > restVelocity;\n\n            if (!isMoving) {\n              finished = Math.abs(to - position) <= precision;\n\n              if (finished) {\n                break;\n              }\n            }\n\n            if (canBounce) {\n              isBouncing = position == to || position > to == isGrowing;\n\n              if (isBouncing) {\n                velocity = -velocity * bounceFactor;\n                position = to;\n              }\n            }\n\n            const springForce = -config.tension * 1e-6 * (position - to);\n            const dampingForce = -config.friction * 1e-3 * velocity;\n            const acceleration = (springForce + dampingForce) / config.mass;\n            velocity = velocity + acceleration * step;\n            position = position + velocity * step;\n          }\n        }\n\n        node2.lastVelocity = velocity;\n\n        if (Number.isNaN(position)) {\n          console.warn(`Got NaN while animating:`, this);\n          finished = true;\n        }\n      }\n\n      if (payload && !payload[i].done) {\n        finished = false;\n      }\n\n      if (finished) {\n        node2.done = true;\n      } else {\n        idle = false;\n      }\n\n      if (node2.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n    const node = getAnimated(this);\n\n    if (idle) {\n      const value = getFluidValue(anim.to);\n\n      if (node.setValue(value) || changed) {\n        this._onChange(value);\n      }\n\n      this._stop();\n    } else if (changed) {\n      this._onChange(node.getValue());\n    }\n  }\n\n  set(value) {\n    raf.batchedUpdates(() => {\n      this._stop();\n\n      this._focus(value);\n\n      this._set(value);\n    });\n    return this;\n  }\n\n  pause() {\n    this._update({\n      pause: true\n    });\n  }\n\n  resume() {\n    this._update({\n      pause: false\n    });\n  }\n\n  finish() {\n    if (isAnimating(this)) {\n      const {\n        to,\n        config\n      } = this.animation;\n      raf.batchedUpdates(() => {\n        this._onStart();\n\n        if (!config.decay) {\n          this._set(to, false);\n        }\n\n        this._stop();\n      });\n    }\n\n    return this;\n  }\n\n  update(props) {\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n\n  start(to, arg2) {\n    let queue;\n\n    if (!is.und(to)) {\n      queue = [is.obj(to) ? to : { ...arg2,\n        to\n      }];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n\n    return Promise.all(queue.map(props => this._update(props))).then(results => getCombinedResult(this, results));\n  }\n\n  stop(cancel) {\n    const {\n      to\n    } = this.animation;\n\n    this._focus(this.get());\n\n    stopAsync(this._state, cancel && this._lastCallId);\n    raf.batchedUpdates(() => this._stop(to, cancel));\n    return this;\n  }\n\n  reset() {\n    this._update({\n      reset: true\n    });\n  }\n\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      this._start();\n    } else if (event.type == \"priority\") {\n      this.priority = event.priority + 1;\n    }\n  }\n\n  _prepareNode(props) {\n    const key = this.key || \"\";\n    let {\n      to,\n      from\n    } = props;\n    to = is.obj(to) ? to[key] : to;\n\n    if (to == null || isAsyncTo(to)) {\n      to = void 0;\n    }\n\n    from = is.obj(from) ? from[key] : from;\n\n    if (from == null) {\n      from = void 0;\n    }\n\n    const range = {\n      to,\n      from\n    };\n\n    if (!hasAnimated(this)) {\n      if (props.reverse) [to, from] = [from, to];\n      from = getFluidValue(from);\n\n      if (!is.und(from)) {\n        this._set(from);\n      } else if (!getAnimated(this)) {\n        this._set(to);\n      }\n    }\n\n    return range;\n  }\n\n  _update({ ...props\n  }, isLoop) {\n    const {\n      key,\n      defaultProps\n    } = this;\n    if (props.default) Object.assign(defaultProps, getDefaultProps(props, (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value));\n    mergeActiveFn(this, props, \"onProps\");\n    sendEvent(this, \"onProps\", props, this);\n\n    const range = this._prepareNode(props);\n\n    if (Object.isFrozen(this)) {\n      throw Error(\"Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?\");\n    }\n\n    const state = this._state;\n    return scheduleProps(++this._lastCallId, {\n      key,\n      props,\n      defaultProps,\n      state,\n      actions: {\n        pause: () => {\n          if (!isPaused(this)) {\n            setPausedBit(this, true);\n            flushCalls(state.pauseQueue);\n            sendEvent(this, \"onPause\", this);\n          }\n        },\n        resume: () => {\n          if (isPaused(this)) {\n            setPausedBit(this, false);\n\n            if (isAnimating(this)) {\n              this._resume();\n            }\n\n            flushCalls(state.resumeQueue);\n            sendEvent(this, \"onResume\", this);\n          }\n        },\n        start: this._merge.bind(this, range)\n      }\n    }).then(result => {\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\n        const nextProps = createLoopUpdate(props);\n\n        if (nextProps) {\n          return this._update(nextProps, true);\n        }\n      }\n\n      return result;\n    });\n  }\n\n  _merge(range, props, resolve) {\n    if (props.cancel) {\n      this.stop(true);\n      return resolve(getCancelledResult(this));\n    }\n\n    const hasToProp = !is.und(range.to);\n    const hasFromProp = !is.und(range.from);\n\n    if (hasToProp || hasFromProp) {\n      if (props.callId > this._lastToId) {\n        this._lastToId = props.callId;\n      } else {\n        return resolve(getCancelledResult(this));\n      }\n    }\n\n    const {\n      key,\n      defaultProps,\n      animation: anim\n    } = this;\n    const {\n      to: prevTo,\n      from: prevFrom\n    } = anim;\n    let {\n      to = prevTo,\n      from = prevFrom\n    } = range;\n\n    if (hasFromProp && !hasToProp && (!props.default || is.und(to))) {\n      to = from;\n    }\n\n    if (props.reverse) [to, from] = [from, to];\n    const hasFromChanged = !isEqual(from, prevFrom);\n\n    if (hasFromChanged) {\n      anim.from = from;\n    }\n\n    from = getFluidValue(from);\n    const hasToChanged = !isEqual(to, prevTo);\n\n    if (hasToChanged) {\n      this._focus(to);\n    }\n\n    const hasAsyncTo = isAsyncTo(props.to);\n    const {\n      config\n    } = anim;\n    const {\n      decay,\n      velocity\n    } = config;\n\n    if (hasToProp || hasFromProp) {\n      config.velocity = 0;\n    }\n\n    if (props.config && !hasAsyncTo) {\n      mergeConfig(config, callProp(props.config, key), props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);\n    }\n\n    let node = getAnimated(this);\n\n    if (!node || is.und(to)) {\n      return resolve(getFinishedResult(this, true));\n    }\n\n    const reset = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key);\n    const value = reset ? from : this.get();\n    const goal = computeGoal(to);\n    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);\n    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\n\n    if (hasToChanged) {\n      const nodeType = getAnimatedType(to);\n\n      if (nodeType !== node.constructor) {\n        if (immediate) {\n          node = this._set(goal);\n        } else throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the \"to\" prop suggests`);\n      }\n    }\n\n    const goalType = node.constructor;\n    let started = hasFluidValue(to);\n    let finished = false;\n\n    if (!started) {\n      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;\n\n      if (hasToChanged || hasValueChanged) {\n        finished = isEqual(computeGoal(value), goal);\n        started = !finished;\n      }\n\n      if (!isEqual(config.decay, decay) || !isEqual(config.velocity, velocity)) {\n        started = true;\n      }\n    }\n\n    if (finished && isAnimating(this)) {\n      if (anim.changed && !reset) {\n        started = true;\n      } else if (!started) {\n        this._stop(prevTo);\n      }\n    }\n\n    if (!hasAsyncTo) {\n      if (started || hasFluidValue(prevTo)) {\n        anim.values = node.getPayload();\n        anim.toValues = hasFluidValue(to) ? null : goalType == AnimatedString ? [1] : toArray(goal);\n      }\n\n      if (anim.immediate != immediate) {\n        anim.immediate = immediate;\n\n        if (!immediate && !reset) {\n          this._set(prevTo);\n        }\n      }\n\n      if (started) {\n        const {\n          onRest\n        } = anim;\n        each(ACTIVE_EVENTS, type => mergeActiveFn(this, props, type));\n        const result = getFinishedResult(this, checkFinished(this, prevTo));\n        flushCalls(this._pendingCalls, result);\n\n        this._pendingCalls.add(resolve);\n\n        if (anim.changed) raf.batchedUpdates(() => {\n          var _a;\n\n          anim.changed = !reset;\n          onRest == null ? void 0 : onRest(result);\n\n          if (reset) {\n            callProp(defaultProps.onRest, result);\n          } else {\n            (_a = anim.onStart) == null ? void 0 : _a.call(anim, this);\n          }\n        });\n      }\n    }\n\n    if (reset) {\n      this._set(value);\n    }\n\n    if (hasAsyncTo) {\n      resolve(runAsync(props.to, props, this._state, this));\n    } else if (started) {\n      this._start();\n    } else if (isAnimating(this) && !hasToChanged) {\n      this._pendingCalls.add(resolve);\n    } else {\n      resolve(getNoopResult(this, value));\n    }\n  }\n\n  _focus(value) {\n    const anim = this.animation;\n\n    if (value !== anim.to) {\n      if (getFluidObservers(this)) {\n        this._detach();\n      }\n\n      anim.to = value;\n\n      if (getFluidObservers(this)) {\n        this._attach();\n      }\n    }\n  }\n\n  _attach() {\n    let priority = 0;\n    const {\n      to\n    } = this.animation;\n\n    if (hasFluidValue(to)) {\n      addFluidObserver(to, this);\n\n      if (isFrameValue(to)) {\n        priority = to.priority + 1;\n      }\n    }\n\n    this.priority = priority;\n  }\n\n  _detach() {\n    const {\n      to\n    } = this.animation;\n\n    if (hasFluidValue(to)) {\n      removeFluidObserver(to, this);\n    }\n  }\n\n  _set(arg, idle = true) {\n    const value = getFluidValue(arg);\n\n    if (!is.und(value)) {\n      const oldNode = getAnimated(this);\n\n      if (!oldNode || !isEqual(value, oldNode.getValue())) {\n        const nodeType = getAnimatedType(value);\n\n        if (!oldNode || oldNode.constructor != nodeType) {\n          setAnimated(this, nodeType.create(value));\n        } else {\n          oldNode.setValue(value);\n        }\n\n        if (oldNode) {\n          raf.batchedUpdates(() => {\n            this._onChange(value, idle);\n          });\n        }\n      }\n    }\n\n    return getAnimated(this);\n  }\n\n  _onStart() {\n    const anim = this.animation;\n\n    if (!anim.changed) {\n      anim.changed = true;\n      sendEvent(this, \"onStart\", this);\n    }\n  }\n\n  _onChange(value, idle) {\n    if (!idle) {\n      this._onStart();\n\n      callProp(this.animation.onChange, value, this);\n    }\n\n    callProp(this.defaultProps.onChange, value, this);\n\n    super._onChange(value, idle);\n  }\n\n  _start() {\n    const anim = this.animation;\n    getAnimated(this).reset(getFluidValue(anim.to));\n\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map(node => node.lastPosition);\n    }\n\n    if (!isAnimating(this)) {\n      setActiveBit(this, true);\n\n      if (!isPaused(this)) {\n        this._resume();\n      }\n    }\n  }\n\n  _resume() {\n    if (Globals.skipAnimation) {\n      this.finish();\n    } else {\n      frameLoop.start(this);\n    }\n  }\n\n  _stop(goal, cancel) {\n    if (isAnimating(this)) {\n      setActiveBit(this, false);\n      const anim = this.animation;\n      each(anim.values, node => {\n        node.done = true;\n      });\n\n      if (anim.toValues) {\n        anim.onChange = anim.onPause = anim.onResume = void 0;\n      }\n\n      callFluidObservers(this, {\n        type: \"idle\",\n        parent: this\n      });\n      const result = cancel ? getCancelledResult(this) : getFinishedResult(this, checkFinished(this, goal != null ? goal : anim.to));\n      flushCalls(this._pendingCalls, result);\n\n      if (anim.changed) {\n        anim.changed = false;\n        sendEvent(this, \"onRest\", result);\n      }\n    }\n  }\n\n}\n\nfunction checkFinished(target, to) {\n  const goal = computeGoal(to);\n  const value = computeGoal(target.get());\n  return isEqual(value, goal);\n}\n\nfunction createLoopUpdate(props, loop = props.loop, to = props.to) {\n  let loopRet = callProp(loop);\n\n  if (loopRet) {\n    const overrides = loopRet !== true && inferTo(loopRet);\n    const reverse = (overrides || props).reverse;\n    const reset = !overrides || overrides.reset;\n    return createUpdate({ ...props,\n      loop,\n      default: false,\n      pause: void 0,\n      to: !reverse || isAsyncTo(to) ? to : void 0,\n      from: reset ? props.from : void 0,\n      reset,\n      ...overrides\n    });\n  }\n}\n\nfunction createUpdate(props) {\n  const {\n    to,\n    from\n  } = props = inferTo(props);\n  const keys = new Set();\n  if (is.obj(to)) findDefined(to, keys);\n  if (is.obj(from)) findDefined(from, keys);\n  props.keys = keys.size ? Array.from(keys) : null;\n  return props;\n}\n\nfunction declareUpdate(props) {\n  const update = createUpdate(props);\n\n  if (is.und(update.default)) {\n    update.default = getDefaultProps(update);\n  }\n\n  return update;\n}\n\nfunction findDefined(values, keys) {\n  eachProp(values, (value, key) => value != null && keys.add(key));\n}\n\nconst ACTIVE_EVENTS = [\"onStart\", \"onRest\", \"onChange\", \"onPause\", \"onResume\"];\n\nfunction mergeActiveFn(target, props, type) {\n  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;\n}\n\nfunction sendEvent(target, type, ...args) {\n  var _a, _b, _c, _d;\n\n  (_b = (_a = target.animation)[type]) == null ? void 0 : _b.call(_a, ...args);\n  (_d = (_c = target.defaultProps)[type]) == null ? void 0 : _d.call(_c, ...args);\n}\n\nconst BATCHED_EVENTS = [\"onStart\", \"onChange\", \"onRest\"];\nlet nextId$1 = 1;\n\nclass Controller {\n  constructor(props, flush2) {\n    this.id = nextId$1++;\n    this.springs = {};\n    this.queue = [];\n    this._lastAsyncId = 0;\n    this._active = new Set();\n    this._changed = new Set();\n    this._started = false;\n    this._state = {\n      paused: false,\n      pauseQueue: new Set(),\n      resumeQueue: new Set(),\n      timeouts: new Set()\n    };\n    this._events = {\n      onStart: new Set(),\n      onChange: new Set(),\n      onRest: new Map()\n    };\n    this._onFrame = this._onFrame.bind(this);\n\n    if (flush2) {\n      this._flush = flush2;\n    }\n\n    if (props) {\n      this.start({\n        default: true,\n        ...props\n      });\n    }\n  }\n\n  get idle() {\n    return !this._state.asyncTo && Object.values(this.springs).every(spring => spring.idle);\n  }\n\n  get() {\n    const values = {};\n    this.each((spring, key) => values[key] = spring.get());\n    return values;\n  }\n\n  set(values) {\n    for (const key in values) {\n      const value = values[key];\n\n      if (!is.und(value)) {\n        this.springs[key].set(value);\n      }\n    }\n  }\n\n  update(props) {\n    if (props) {\n      this.queue.push(createUpdate(props));\n    }\n\n    return this;\n  }\n\n  start(props) {\n    let {\n      queue\n    } = this;\n\n    if (props) {\n      queue = toArray(props).map(createUpdate);\n    } else {\n      this.queue = [];\n    }\n\n    if (this._flush) {\n      return this._flush(this, queue);\n    }\n\n    prepareKeys(this, queue);\n    return flushUpdateQueue(this, queue);\n  }\n\n  stop(arg, keys) {\n    if (arg !== !!arg) {\n      keys = arg;\n    }\n\n    if (keys) {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].stop(!!arg));\n    } else {\n      stopAsync(this._state, this._lastAsyncId);\n      this.each(spring => spring.stop(!!arg));\n    }\n\n    return this;\n  }\n\n  pause(keys) {\n    if (is.und(keys)) {\n      this.start({\n        pause: true\n      });\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].pause());\n    }\n\n    return this;\n  }\n\n  resume(keys) {\n    if (is.und(keys)) {\n      this.start({\n        pause: false\n      });\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].resume());\n    }\n\n    return this;\n  }\n\n  each(iterator) {\n    eachProp(this.springs, iterator);\n  }\n\n  _onFrame() {\n    const {\n      onStart,\n      onChange,\n      onRest\n    } = this._events;\n    const active = this._active.size > 0;\n\n    if (active && !this._started) {\n      this._started = true;\n      flushCalls(onStart, this);\n    }\n\n    const idle = !active && this._started;\n    const changed = this._changed.size > 0 && onChange.size;\n    const values = changed || idle && onRest.size ? this.get() : null;\n\n    if (changed) {\n      flushCalls(onChange, values);\n    }\n\n    if (idle) {\n      this._started = false;\n      flush(onRest, ([onRest2, result]) => {\n        result.value = values;\n        onRest2(result);\n      });\n    }\n  }\n\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      this._changed.add(event.parent);\n\n      if (!event.idle) {\n        this._active.add(event.parent);\n      }\n    } else if (event.type == \"idle\") {\n      this._active.delete(event.parent);\n    } else return;\n\n    raf.onFrame(this._onFrame);\n  }\n\n}\n\nfunction flushUpdateQueue(ctrl, queue) {\n  return Promise.all(queue.map(props => flushUpdate(ctrl, props))).then(results => getCombinedResult(ctrl, results));\n}\n\nasync function flushUpdate(ctrl, props, isLoop) {\n  const {\n    keys,\n    to,\n    from,\n    loop,\n    onRest,\n    onResolve\n  } = props;\n  const defaults = is.obj(props.default) && props.default;\n\n  if (loop) {\n    props.loop = false;\n  }\n\n  if (to === false) props.to = null;\n  if (from === false) props.from = null;\n  const asyncTo = is.arr(to) || is.fun(to) ? to : void 0;\n\n  if (asyncTo) {\n    props.to = void 0;\n    props.onRest = void 0;\n\n    if (defaults) {\n      defaults.onRest = void 0;\n    }\n  } else {\n    each(BATCHED_EVENTS, key => {\n      const handler = props[key];\n\n      if (is.fun(handler)) {\n        const queue = ctrl[\"_events\"][key];\n\n        if (queue instanceof Set) {\n          props[key] = () => queue.add(handler);\n        } else {\n          props[key] = ({\n            finished,\n            cancelled\n          }) => {\n            const result2 = queue.get(handler);\n\n            if (result2) {\n              if (!finished) result2.finished = false;\n              if (cancelled) result2.cancelled = true;\n            } else {\n              queue.set(handler, {\n                target: ctrl,\n                value: null,\n                finished,\n                cancelled\n              });\n            }\n          };\n        }\n\n        if (defaults) {\n          defaults[key] = props[key];\n        }\n      }\n    });\n  }\n\n  const state = ctrl[\"_state\"];\n\n  if (props.pause === !state.paused) {\n    state.paused = props.pause;\n    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);\n  } else if (state.paused) {\n    props.pause = true;\n  }\n\n  const promises = (keys || Object.keys(ctrl.springs)).map(key => ctrl.springs[key].start(props));\n  const cancel = props.cancel === true || getDefaultProp(props, \"cancel\") === true;\n\n  if (asyncTo || cancel && state.asyncId) {\n    promises.push(scheduleProps(++ctrl[\"_lastAsyncId\"], {\n      props,\n      state,\n      actions: {\n        pause: noop,\n        resume: noop,\n\n        start(props2, resolve) {\n          if (cancel) {\n            stopAsync(state, ctrl[\"_lastAsyncId\"]);\n            resolve(getCancelledResult(ctrl));\n          } else {\n            props2.onRest = onRest;\n            resolve(runAsync(asyncTo, props2, state, ctrl));\n          }\n        }\n\n      }\n    }));\n  }\n\n  if (state.paused) {\n    await new Promise(resume => {\n      state.resumeQueue.add(resume);\n    });\n  }\n\n  const result = getCombinedResult(ctrl, await Promise.all(promises));\n\n  if (loop && result.finished && !(isLoop && result.noop)) {\n    const nextProps = createLoopUpdate(props, loop, to);\n\n    if (nextProps) {\n      prepareKeys(ctrl, [nextProps]);\n      return flushUpdate(ctrl, nextProps, true);\n    }\n  }\n\n  if (onResolve) {\n    raf.batchedUpdates(() => onResolve(result));\n  }\n\n  return result;\n}\n\nfunction getSprings(ctrl, props) {\n  const springs = { ...ctrl.springs\n  };\n\n  if (props) {\n    each(toArray(props), props2 => {\n      if (is.und(props2.keys)) {\n        props2 = createUpdate(props2);\n      }\n\n      if (!is.obj(props2.to)) {\n        props2 = { ...props2,\n          to: void 0\n        };\n      }\n\n      prepareSprings(springs, props2, key => {\n        return createSpring(key);\n      });\n    });\n  }\n\n  return springs;\n}\n\nfunction setSprings(ctrl, springs) {\n  eachProp(springs, (spring, key) => {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring;\n      addFluidObserver(spring, ctrl);\n    }\n  });\n}\n\nfunction createSpring(key, observer) {\n  const spring = new SpringValue();\n  spring.key = key;\n\n  if (observer) {\n    addFluidObserver(spring, observer);\n  }\n\n  return spring;\n}\n\nfunction prepareSprings(springs, props, create) {\n  if (props.keys) {\n    each(props.keys, key => {\n      const spring = springs[key] || (springs[key] = create(key));\n      spring[\"_prepareNode\"](props);\n    });\n  }\n}\n\nfunction prepareKeys(ctrl, queue) {\n  each(queue, props => {\n    prepareSprings(ctrl.springs, props, key => {\n      return createSpring(key, ctrl);\n    });\n  });\n}\n\nconst SpringContext = ({\n  children,\n  ...props\n}) => {\n  const inherited = useContext(ctx);\n  const pause = props.pause || !!inherited.pause,\n        immediate = props.immediate || !!inherited.immediate;\n  props = useMemoOne(() => ({\n    pause,\n    immediate\n  }), [pause, immediate]);\n  const {\n    Provider\n  } = ctx;\n  return /* @__PURE__ */createElement(Provider, {\n    value: props\n  }, children);\n};\n\nconst ctx = makeContext(SpringContext, {});\nSpringContext.Provider = ctx.Provider;\nSpringContext.Consumer = ctx.Consumer;\n\nfunction makeContext(target, init) {\n  Object.assign(target, createContext(init));\n  target.Provider._context = target;\n  target.Consumer._context = target;\n  return target;\n}\n\nclass SpringRef {\n  constructor() {\n    this.current = [];\n  }\n\n  set(values) {\n    each(this.current, ctrl => ctrl.set(values));\n  }\n\n  start(props) {\n    const results = [];\n    each(this.current, (ctrl, i) => {\n      if (is.und(props)) {\n        results.push(ctrl.start());\n      } else {\n        const update = this._getProps(props, ctrl, i);\n\n        if (update) {\n          results.push(ctrl.start(update));\n        }\n      }\n    });\n    return results;\n  }\n\n  update(props) {\n    each(this.current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));\n    return this;\n  }\n\n  add(ctrl) {\n    if (!this.current.includes(ctrl)) {\n      this.current.push(ctrl);\n    }\n  }\n\n  delete(ctrl) {\n    const i = this.current.indexOf(ctrl);\n    if (~i) this.current.splice(i, 1);\n  }\n\n  _getProps(arg, ctrl, index) {\n    return is.fun(arg) ? arg(index, ctrl) : arg;\n  }\n\n}\n\neach([\"stop\", \"pause\", \"resume\"], key => {\n  SpringRef.prototype[key] = function () {\n    each(this.current, ctrl => ctrl[key](...arguments));\n    return this;\n  };\n});\n\nfunction useSprings(length, props, deps) {\n  const propsFn = is.fun(props) && props;\n  if (propsFn && !deps) deps = [];\n  const ref = useMemo(() => propsFn || arguments.length == 3 ? new SpringRef() : void 0, []);\n  const layoutId = useRef(0);\n  const forceUpdate = useForceUpdate();\n  const state = useMemo(() => ({\n    ctrls: [],\n    queue: [],\n\n    flush(ctrl, updates2) {\n      const springs2 = getSprings(ctrl, updates2);\n      const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some(key => !ctrl.springs[key]);\n      return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise(resolve => {\n        setSprings(ctrl, springs2);\n        state.queue.push(() => {\n          resolve(flushUpdateQueue(ctrl, updates2));\n        });\n        forceUpdate();\n      });\n    }\n\n  }), []);\n  const ctrls = [...state.ctrls];\n  const updates = [];\n  const prevLength = usePrev(length) || 0;\n  const oldCtrls = ctrls.slice(length, prevLength);\n  useMemo(() => {\n    ctrls.length = length;\n    declareUpdates(prevLength, length);\n  }, [length]);\n  useMemo(() => {\n    declareUpdates(0, Math.min(prevLength, length));\n  }, deps);\n\n  function declareUpdates(startIndex, endIndex) {\n    for (let i = startIndex; i < endIndex; i++) {\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller(null, state.flush));\n      const update = propsFn ? propsFn(i, ctrl) : props[i];\n\n      if (update) {\n        updates[i] = declareUpdate(update);\n      }\n    }\n  }\n\n  const springs = ctrls.map((ctrl, i) => getSprings(ctrl, updates[i]));\n  const context = useContext(SpringContext);\n  const prevContext = usePrev(context);\n  const hasContext = context !== prevContext && hasProps(context);\n  useLayoutEffect(() => {\n    layoutId.current++;\n    state.ctrls = ctrls;\n    const {\n      queue\n    } = state;\n\n    if (queue.length) {\n      state.queue = [];\n      each(queue, cb => cb());\n    }\n\n    each(oldCtrls, ctrl => {\n      detachRefs(ctrl, ref);\n      ctrl.stop(true);\n    });\n    each(ctrls, (ctrl, i) => {\n      const values2 = springs[i];\n      setSprings(ctrl, values2);\n      ref == null ? void 0 : ref.add(ctrl);\n\n      if (hasContext) {\n        ctrl.start({\n          default: context\n        });\n      }\n\n      const update = updates[i];\n\n      if (update) {\n        replaceRef(ctrl, update.ref);\n\n        if (ctrl.ref) {\n          ctrl.queue.push(update);\n        } else {\n          ctrl.start(update);\n        }\n      }\n    });\n  });\n  useOnce(() => () => {\n    each(state.ctrls, ctrl => ctrl.stop(true));\n  });\n  const values = springs.map(x => ({ ...x\n  }));\n  return ref ? [values, ref] : values;\n}\n\nfunction useSpring(props, deps) {\n  const isFn = is.fun(props);\n  const [[values], ref] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);\n  return isFn || arguments.length == 2 ? [values, ref] : values;\n}\n\nconst initSpringRef = () => new SpringRef();\n\nconst useSpringRef = () => useState(initSpringRef)[0];\n\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = is.fun(propsArg) && propsArg;\n  if (propsFn && !deps) deps = [];\n  let reverse = true;\n  const result = useSprings(length, (i, ctrl) => {\n    const props = propsFn ? propsFn(i, ctrl) : propsArg;\n    reverse = reverse && props.reverse;\n    return props;\n  }, deps || [{}]);\n  const ref = result[1];\n  useLayoutEffect(() => {\n    each(ref.current, (ctrl, i) => {\n      const parent = ref.current[i + (reverse ? 1 : -1)];\n      if (parent) ctrl.start({\n        to: parent.springs\n      });\n    });\n  }, deps);\n\n  if (propsFn || arguments.length == 3) {\n    ref[\"_getProps\"] = (propsArg2, ctrl, i) => {\n      const props = is.fun(propsArg2) ? propsArg2(i, ctrl) : propsArg2;\n\n      if (props) {\n        const parent = ref.current[i + (props.reverse ? 1 : -1)];\n        if (parent) props.to = parent.springs;\n        return props;\n      }\n    };\n\n    return result;\n  }\n\n  return result[0];\n}\n\nconst MOUNT = \"mount\";\nconst ENTER = \"enter\";\nconst UPDATE = \"update\";\nconst LEAVE = \"leave\";\n\nfunction useTransition(data, props, deps) {\n  const {\n    reset,\n    sort,\n    trail = 0,\n    expires = true,\n    onDestroyed\n  } = props;\n  const ref = useMemo(() => arguments.length == 3 ? new SpringRef() : void 0, []);\n  const items = toArray(data);\n  const transitions = [];\n  const usedTransitions = useRef(null);\n  const prevTransitions = reset ? null : usedTransitions.current;\n  useLayoutEffect(() => {\n    usedTransitions.current = transitions;\n  });\n  useOnce(() => () => each(usedTransitions.current, t => {\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n    }\n\n    detachRefs(t.ctrl, ref);\n    t.ctrl.stop(true);\n  }));\n  const keys = getKeys(items, props, prevTransitions);\n  const expired = reset && usedTransitions.current || [];\n  useLayoutEffect(() => each(expired, ({\n    ctrl,\n    item,\n    key\n  }) => {\n    detachRefs(ctrl, ref);\n    callProp(onDestroyed, item, key);\n  }));\n  const reused = [];\n  if (prevTransitions) each(prevTransitions, (t, i) => {\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n      expired.push(t);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  });\n  each(items, (item, i) => {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  });\n\n  if (reused.length) {\n    let i = -1;\n    each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = { ...t,\n          item: items[keyIndex]\n        };\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  }\n\n  let delay = -trail;\n  const forceUpdate = useForceUpdate();\n  const defaultProps = getDefaultProps(props);\n  const changes = new Map();\n  each(transitions, (t, i) => {\n    const key = t.key;\n    const prevPhase = t.phase;\n    let to;\n    let phase;\n\n    if (prevPhase == MOUNT) {\n      to = props.enter;\n      phase = ENTER;\n    } else {\n      const isLeave = keys.indexOf(key) < 0;\n\n      if (prevPhase != LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    }\n\n    to = callProp(to, t.item, i);\n    to = is.obj(to) ? inferTo(to) : {\n      to\n    };\n\n    if (!to.config) {\n      const config = props.config || defaultProps.config;\n      to.config = callProp(config, t.item, i);\n    }\n\n    const payload = { ...defaultProps,\n      delay: delay += trail,\n      reset: false,\n      ...to\n    };\n\n    if (phase == ENTER && is.und(payload.from)) {\n      const from = is.und(props.initial) || prevTransitions ? props.from : props.initial;\n      payload.from = callProp(from, t.item, i);\n    }\n\n    const {\n      onResolve\n    } = payload;\n\n    payload.onResolve = result => {\n      callProp(onResolve, result);\n      const transitions2 = usedTransitions.current;\n      const t2 = transitions2.find(t3 => t3.key === key);\n      if (!t2) return;\n\n      if (result.cancelled && t2.phase != UPDATE) {\n        t2.phase = prevPhase;\n        return;\n      }\n\n      if (t2.ctrl.idle) {\n        const idle = transitions2.every(t3 => t3.ctrl.idle);\n\n        if (t2.phase == LEAVE) {\n          const expiry = callProp(expires, t2.item);\n\n          if (expiry !== false) {\n            const expiryMs = expiry === true ? 0 : expiry;\n            t2.expired = true;\n\n            if (!idle && expiryMs > 0) {\n              if (expiryMs <= 2147483647) t2.expirationId = setTimeout(forceUpdate, expiryMs);\n              return;\n            }\n          }\n        }\n\n        if (idle && transitions2.some(t3 => t3.expired)) {\n          forceUpdate();\n        }\n      }\n    };\n\n    const springs = getSprings(t.ctrl, payload);\n    changes.set(t, {\n      phase,\n      springs,\n      payload\n    });\n  });\n  const context = useContext(SpringContext);\n  const prevContext = usePrev(context);\n  const hasContext = context !== prevContext && hasProps(context);\n  useLayoutEffect(() => {\n    if (hasContext) each(transitions, t => {\n      t.ctrl.start({\n        default: context\n      });\n    });\n  }, [context]);\n  useLayoutEffect(() => {\n    each(changes, ({\n      phase,\n      springs,\n      payload\n    }, t) => {\n      const {\n        ctrl\n      } = t;\n      t.phase = phase;\n      ref == null ? void 0 : ref.add(ctrl);\n      replaceRef(ctrl, payload.ref);\n      setSprings(ctrl, springs);\n\n      if (hasContext && phase == ENTER) {\n        ctrl.start({\n          default: context\n        });\n      }\n\n      ctrl[ctrl.ref ? \"update\" : \"start\"](payload);\n    });\n  }, reset ? void 0 : deps);\n\n  const renderTransitions = render => /* @__PURE__ */createElement(Fragment, null, transitions.map((t, i) => {\n    const {\n      springs\n    } = changes.get(t) || t.ctrl;\n    const elem = render({ ...springs\n    }, t.item, t, i);\n    return elem && elem.type ? /* @__PURE__ */createElement(elem.type, { ...elem.props,\n      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\n      ref: elem.ref\n    }) : elem;\n  }));\n\n  return ref ? [renderTransitions, ref] : renderTransitions;\n}\n\nlet nextKey = 1;\n\nfunction getKeys(items, {\n  key,\n  keys = key\n}, prevTransitions) {\n  if (keys === null) {\n    const reused = new Set();\n    return items.map(item => {\n      const t = prevTransitions && prevTransitions.find(t2 => t2.item === item && t2.phase !== LEAVE && !reused.has(t2));\n\n      if (t) {\n        reused.add(t);\n        return t.key;\n      }\n\n      return nextKey++;\n    });\n  }\n\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\n}\n\nfunction Spring({\n  children,\n  ...props\n}) {\n  return children(useSpring(props));\n}\n\nfunction Trail({\n  items,\n  children,\n  ...props\n}) {\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nfunction Transition({\n  items,\n  children,\n  ...props\n}) {\n  return useTransition(items, props)(children);\n}\n\nclass Interpolation extends FrameValue {\n  constructor(source, args) {\n    super();\n    this.source = source;\n    this.idle = true;\n    this._active = new Set();\n    this.calc = createInterpolator(...args);\n\n    const value = this._get();\n\n    const nodeType = getAnimatedType(value);\n    setAnimated(this, nodeType.create(value));\n  }\n\n  advance(_dt) {\n    const value = this._get();\n\n    const oldValue = this.get();\n\n    if (!isEqual(value, oldValue)) {\n      getAnimated(this).setValue(value);\n\n      this._onChange(value, this.idle);\n    }\n\n    if (!this.idle && checkIdle(this._active)) {\n      becomeIdle(this);\n    }\n  }\n\n  _get() {\n    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));\n    return this.calc(...inputs);\n  }\n\n  _start() {\n    if (this.idle && !checkIdle(this._active)) {\n      this.idle = false;\n      each(getPayload(this), node => {\n        node.done = false;\n      });\n\n      if (Globals.skipAnimation) {\n        raf.batchedUpdates(() => this.advance());\n        becomeIdle(this);\n      } else {\n        frameLoop.start(this);\n      }\n    }\n  }\n\n  _attach() {\n    let priority = 1;\n    each(toArray(this.source), source => {\n      if (hasFluidValue(source)) {\n        addFluidObserver(source, this);\n      }\n\n      if (isFrameValue(source)) {\n        if (!source.idle) {\n          this._active.add(source);\n        }\n\n        priority = Math.max(priority, source.priority + 1);\n      }\n    });\n    this.priority = priority;\n\n    this._start();\n  }\n\n  _detach() {\n    each(toArray(this.source), source => {\n      if (hasFluidValue(source)) {\n        removeFluidObserver(source, this);\n      }\n    });\n\n    this._active.clear();\n\n    becomeIdle(this);\n  }\n\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      if (event.idle) {\n        this.advance();\n      } else {\n        this._active.add(event.parent);\n\n        this._start();\n      }\n    } else if (event.type == \"idle\") {\n      this._active.delete(event.parent);\n    } else if (event.type == \"priority\") {\n      this.priority = toArray(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);\n    }\n  }\n\n}\n\nfunction isIdle(source) {\n  return source.idle !== false;\n}\n\nfunction checkIdle(active) {\n  return !active.size || Array.from(active).every(isIdle);\n}\n\nfunction becomeIdle(self) {\n  if (!self.idle) {\n    self.idle = true;\n    each(getPayload(self), node => {\n      node.done = true;\n    });\n    callFluidObservers(self, {\n      type: \"idle\",\n      parent: self\n    });\n  }\n}\n\nconst to = (source, ...args) => new Interpolation(source, args);\n\nconst interpolate = (source, ...args) => (deprecateInterpolate(), new Interpolation(source, args));\n\nGlobals.assign({\n  createStringInterpolator,\n  to: (source, args) => new Interpolation(source, args)\n});\nconst update = frameLoop.advance;\nexport { BailSignal, Controller, FrameValue, Interpolation, Spring, SpringContext, SpringRef, SpringValue, Trail, Transition, config, inferTo, interpolate, to, update, useChain, useSpring, useSpringRef, useSprings, useTrail, useTransition };","map":{"version":3,"sources":["src/helpers.ts","src/hooks/useChain.ts","src/constants.ts","src/AnimationConfig.ts","src/Animation.ts","src/scheduleProps.ts","src/AnimationResult.ts","src/runAsync.ts","src/FrameValue.ts","src/SpringPhase.ts","src/SpringValue.ts","src/Controller.ts","src/SpringContext.tsx","src/SpringRef.ts","src/hooks/useSprings.ts","src/hooks/useSpring.ts","src/hooks/useSpringRef.ts","src/hooks/useTrail.ts","src/TransitionPhase.ts","src/hooks/useTransition.tsx","src/components/Spring.tsx","src/components/Trail.tsx","src/components/Transition.tsx","src/Interpolation.ts","src/interpolate.ts","src/globals.ts"],"names":["G","configs","AnimationConfig2","Animation2","scheduleProps2","runAsync2","nextId","SpringValue2","React.createContext","SpringRef2","Controller2","SpringContext2","useSprings2","useSpring2","useTrail2","Interpolation2"],"mappings":"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","sourcesContent":["import { useLayoutEffect } from 'react-layout-effect';\r\nimport { eachProp, is, toArray, isAnimatedString, Globals, getFluidValue, each, raf, flush, FluidValue, deprecateInterpolate, callFluidObservers, frameLoop, hasFluidValue, flushCalls, isEqual, getFluidObservers, addFluidObserver, removeFluidObserver, noop, useMemoOne, useForceUpdate, usePrev, useOnce, createInterpolator, createStringInterpolator } from '@react-spring/shared';\r\nexport { Globals, createInterpolator } from '@react-spring/shared';\r\nimport { useContext, createElement, createContext, useMemo, useRef, useState, Fragment } from 'react';\r\nimport { getAnimated, AnimatedValue, getPayload, AnimatedString, getAnimatedType, setAnimated } from '@react-spring/animated';\r\nexport * from '@react-spring/types/animated';\r\nexport * from '@react-spring/types/interpolation';\r\n\r\nfunction callProp(value, ...args) {\r\n  return is.fun(value) ? value(...args) : value;\r\n}\r\nconst matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\r\nconst resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;\r\nconst getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;\r\nconst noopTransform = (value) => value;\r\nconst getDefaultProps = (props, transform = noopTransform) => {\r\n  let keys = DEFAULT_PROPS;\r\n  if (props.default && props.default !== true) {\r\n    props = props.default;\r\n    keys = Object.keys(props);\r\n  }\r\n  const defaults = {};\r\n  for (const key of keys) {\r\n    const value = transform(props[key], key);\r\n    if (!is.und(value)) {\r\n      defaults[key] = value;\r\n    }\r\n  }\r\n  return defaults;\r\n};\r\nconst DEFAULT_PROPS = [\r\n  \"config\",\r\n  \"onProps\",\r\n  \"onStart\",\r\n  \"onChange\",\r\n  \"onPause\",\r\n  \"onResume\",\r\n  \"onRest\"\r\n];\r\nconst RESERVED_PROPS = {\r\n  config: 1,\r\n  from: 1,\r\n  to: 1,\r\n  ref: 1,\r\n  loop: 1,\r\n  reset: 1,\r\n  pause: 1,\r\n  cancel: 1,\r\n  reverse: 1,\r\n  immediate: 1,\r\n  default: 1,\r\n  delay: 1,\r\n  onProps: 1,\r\n  onStart: 1,\r\n  onChange: 1,\r\n  onPause: 1,\r\n  onResume: 1,\r\n  onRest: 1,\r\n  onResolve: 1,\r\n  items: 1,\r\n  trail: 1,\r\n  sort: 1,\r\n  expires: 1,\r\n  initial: 1,\r\n  enter: 1,\r\n  update: 1,\r\n  leave: 1,\r\n  children: 1,\r\n  onDestroyed: 1,\r\n  keys: 1,\r\n  callId: 1,\r\n  parentId: 1\r\n};\r\nfunction getForwardProps(props) {\r\n  const forward = {};\r\n  let count = 0;\r\n  eachProp(props, (value, prop) => {\r\n    if (!RESERVED_PROPS[prop]) {\r\n      forward[prop] = value;\r\n      count++;\r\n    }\r\n  });\r\n  if (count) {\r\n    return forward;\r\n  }\r\n}\r\nfunction inferTo(props) {\r\n  const to = getForwardProps(props);\r\n  if (to) {\r\n    const out = {to};\r\n    eachProp(props, (val, key) => key in to || (out[key] = val));\r\n    return out;\r\n  }\r\n  return {...props};\r\n}\r\nfunction computeGoal(value) {\r\n  value = getFluidValue(value);\r\n  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? Globals.createStringInterpolator({\r\n    range: [0, 1],\r\n    output: [value, value]\r\n  })(1) : value;\r\n}\r\nfunction hasProps(props) {\r\n  for (const _ in props)\r\n    return true;\r\n  return false;\r\n}\r\nfunction isAsyncTo(to) {\r\n  return is.fun(to) || is.arr(to) && is.obj(to[0]);\r\n}\r\nfunction detachRefs(ctrl, ref) {\r\n  var _a;\r\n  (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);\r\n  ref == null ? void 0 : ref.delete(ctrl);\r\n}\r\nfunction replaceRef(ctrl, ref) {\r\n  var _a;\r\n  if (ref && ctrl.ref !== ref) {\r\n    (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);\r\n    ref.add(ctrl);\r\n    ctrl.ref = ref;\r\n  }\r\n}\r\n\r\nfunction useChain(refs, timeSteps, timeFrame = 1e3) {\r\n  useLayoutEffect(() => {\r\n    if (timeSteps) {\r\n      let prevDelay = 0;\r\n      each(refs, (ref, i) => {\r\n        const controllers = ref.current;\r\n        if (controllers.length) {\r\n          let delay = timeFrame * timeSteps[i];\r\n          if (isNaN(delay))\r\n            delay = prevDelay;\r\n          else\r\n            prevDelay = delay;\r\n          each(controllers, (ctrl) => {\r\n            each(ctrl.queue, (props) => {\r\n              props.delay = (key) => delay + callProp(props.delay || 0, key);\r\n            });\r\n            ctrl.start();\r\n          });\r\n        }\r\n      });\r\n    } else {\r\n      let p = Promise.resolve();\r\n      each(refs, (ref) => {\r\n        const controllers = ref.current;\r\n        if (controllers.length) {\r\n          const queues = controllers.map((ctrl) => {\r\n            const q = ctrl.queue;\r\n            ctrl.queue = [];\r\n            return q;\r\n          });\r\n          p = p.then(() => {\r\n            each(controllers, (ctrl, i) => each(queues[i] || [], (update) => ctrl.queue.push(update)));\r\n            return ref.start();\r\n          });\r\n        }\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\nconst config = {\r\n  default: {tension: 170, friction: 26},\r\n  gentle: {tension: 120, friction: 14},\r\n  wobbly: {tension: 180, friction: 12},\r\n  stiff: {tension: 210, friction: 20},\r\n  slow: {tension: 280, friction: 60},\r\n  molasses: {tension: 280, friction: 120}\r\n};\r\n\r\nconst linear = (t) => t;\r\nconst defaults = {\r\n  ...config.default,\r\n  mass: 1,\r\n  damping: 1,\r\n  easing: linear,\r\n  clamp: false\r\n};\r\nclass AnimationConfig {\r\n  constructor() {\r\n    this.velocity = 0;\r\n    Object.assign(this, defaults);\r\n  }\r\n}\r\nfunction mergeConfig(config, newConfig, defaultConfig) {\r\n  if (defaultConfig) {\r\n    defaultConfig = {...defaultConfig};\r\n    sanitizeConfig(defaultConfig, newConfig);\r\n    newConfig = {...defaultConfig, ...newConfig};\r\n  }\r\n  sanitizeConfig(config, newConfig);\r\n  Object.assign(config, newConfig);\r\n  for (const key in defaults) {\r\n    if (config[key] == null) {\r\n      config[key] = defaults[key];\r\n    }\r\n  }\r\n  let {mass, frequency, damping} = config;\r\n  if (!is.und(frequency)) {\r\n    if (frequency < 0.01)\r\n      frequency = 0.01;\r\n    if (damping < 0)\r\n      damping = 0;\r\n    config.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\r\n    config.friction = 4 * Math.PI * damping * mass / frequency;\r\n  }\r\n  return config;\r\n}\r\nfunction sanitizeConfig(config, props) {\r\n  if (!is.und(props.decay)) {\r\n    config.duration = void 0;\r\n  } else {\r\n    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);\r\n    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {\r\n      config.duration = void 0;\r\n      config.decay = void 0;\r\n    }\r\n    if (isTensionConfig) {\r\n      config.frequency = void 0;\r\n    }\r\n  }\r\n}\r\n\r\nconst emptyArray = [];\r\nclass Animation {\r\n  constructor() {\r\n    this.changed = false;\r\n    this.values = emptyArray;\r\n    this.toValues = null;\r\n    this.fromValues = emptyArray;\r\n    this.config = new AnimationConfig();\r\n    this.immediate = false;\r\n  }\r\n}\r\n\r\nfunction scheduleProps(callId, {key, props, defaultProps, state, actions}) {\r\n  return new Promise((resolve, reject) => {\r\n    var _a;\r\n    let delay;\r\n    let timeout;\r\n    let cancel = matchProp((_a = props.cancel) != null ? _a : defaultProps == null ? void 0 : defaultProps.cancel, key);\r\n    if (cancel) {\r\n      onStart();\r\n    } else {\r\n      if (!is.und(props.pause)) {\r\n        state.paused = matchProp(props.pause, key);\r\n      }\r\n      let pause = defaultProps == null ? void 0 : defaultProps.pause;\r\n      if (pause !== true) {\r\n        pause = state.paused || matchProp(pause, key);\r\n      }\r\n      delay = callProp(props.delay || 0, key);\r\n      if (pause) {\r\n        state.resumeQueue.add(onResume);\r\n        actions.pause();\r\n      } else {\r\n        actions.resume();\r\n        onResume();\r\n      }\r\n    }\r\n    function onPause() {\r\n      state.resumeQueue.add(onResume);\r\n      state.timeouts.delete(timeout);\r\n      timeout.cancel();\r\n      delay = timeout.time - raf.now();\r\n    }\r\n    function onResume() {\r\n      if (delay > 0) {\r\n        timeout = raf.setTimeout(onStart, delay);\r\n        state.pauseQueue.add(onPause);\r\n        state.timeouts.add(timeout);\r\n      } else {\r\n        onStart();\r\n      }\r\n    }\r\n    function onStart() {\r\n      state.pauseQueue.delete(onPause);\r\n      state.timeouts.delete(timeout);\r\n      if (callId <= (state.cancelId || 0)) {\r\n        cancel = true;\r\n      }\r\n      try {\r\n        actions.start({...props, callId, cancel}, resolve);\r\n      } catch (err) {\r\n        reject(err);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nconst getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target) : results.every((result) => result.noop) ? getNoopResult(target) : getFinishedResult(target, results.every((result) => result.finished));\r\nconst getNoopResult = (target, value = target.get()) => ({\r\n  value,\r\n  noop: true,\r\n  finished: true,\r\n  target\r\n});\r\nconst getFinishedResult = (target, finished, value = target.get()) => ({\r\n  value,\r\n  finished,\r\n  target\r\n});\r\nconst getCancelledResult = (target, value = target.get()) => ({\r\n  value,\r\n  cancelled: true,\r\n  target\r\n});\r\n\r\nfunction runAsync(to, props, state, target) {\r\n  const {callId, parentId, onRest} = props;\r\n  const {asyncTo: prevTo, promise: prevPromise} = state;\r\n  if (!parentId && to === prevTo && !props.reset) {\r\n    return prevPromise;\r\n  }\r\n  return state.promise = (async () => {\r\n    state.asyncId = callId;\r\n    state.asyncTo = to;\r\n    const defaultProps = getDefaultProps(props, (value, key) => key === \"onRest\" ? void 0 : value);\r\n    let preventBail;\r\n    let bail;\r\n    const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));\r\n    const bailIfEnded = (bailSignal) => {\r\n      const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);\r\n      if (bailResult) {\r\n        bailSignal.result = bailResult;\r\n        bail(bailSignal);\r\n        throw bailSignal;\r\n      }\r\n    };\r\n    const animate = (arg1, arg2) => {\r\n      const bailSignal = new BailSignal();\r\n      return (async () => {\r\n        bailIfEnded(bailSignal);\r\n        const props2 = is.obj(arg1) ? {...arg1} : {...arg2, to: arg1};\r\n        props2.parentId = callId;\r\n        eachProp(defaultProps, (value, key) => {\r\n          if (is.und(props2[key])) {\r\n            props2[key] = value;\r\n          }\r\n        });\r\n        const result2 = await target.start(props2);\r\n        bailIfEnded(bailSignal);\r\n        if (state.paused) {\r\n          await new Promise((resume) => {\r\n            state.resumeQueue.add(resume);\r\n          });\r\n        }\r\n        return result2;\r\n      })();\r\n    };\r\n    let result;\r\n    try {\r\n      let animating;\r\n      if (is.arr(to)) {\r\n        animating = (async (queue) => {\r\n          for (const props2 of queue) {\r\n            await animate(props2);\r\n          }\r\n        })(to);\r\n      } else {\r\n        animating = Promise.resolve(to(animate, target.stop.bind(target)));\r\n      }\r\n      await Promise.all([animating.then(preventBail), bailPromise]);\r\n      result = getFinishedResult(target, true);\r\n    } catch (err) {\r\n      if (err instanceof BailSignal) {\r\n        result = err.result;\r\n      } else {\r\n        throw err;\r\n      }\r\n    } finally {\r\n      if (callId == state.asyncId) {\r\n        state.asyncId = parentId;\r\n        state.asyncTo = parentId ? prevTo : void 0;\r\n        state.promise = parentId ? prevPromise : void 0;\r\n      }\r\n    }\r\n    if (is.fun(onRest)) {\r\n      raf.batchedUpdates(() => {\r\n        onRest(result);\r\n      });\r\n    }\r\n    return result;\r\n  })();\r\n}\r\nfunction stopAsync(state, cancelId) {\r\n  flush(state.timeouts, (t) => t.cancel());\r\n  state.pauseQueue.clear();\r\n  state.resumeQueue.clear();\r\n  state.asyncId = state.asyncTo = state.promise = void 0;\r\n  if (cancelId)\r\n    state.cancelId = cancelId;\r\n}\r\nclass BailSignal extends Error {\r\n  constructor() {\r\n    super(\"An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.\");\r\n  }\r\n}\r\n\r\nconst isFrameValue = (value) => value instanceof FrameValue;\r\nlet nextId = 1;\r\nclass FrameValue extends FluidValue {\r\n  constructor() {\r\n    super(...arguments);\r\n    this.id = nextId++;\r\n    this._priority = 0;\r\n  }\r\n  get priority() {\r\n    return this._priority;\r\n  }\r\n  set priority(priority) {\r\n    if (this._priority != priority) {\r\n      this._priority = priority;\r\n      this._onPriorityChange(priority);\r\n    }\r\n  }\r\n  get() {\r\n    const node = getAnimated(this);\r\n    return node && node.getValue();\r\n  }\r\n  to(...args) {\r\n    return Globals.to(this, args);\r\n  }\r\n  interpolate(...args) {\r\n    deprecateInterpolate();\r\n    return Globals.to(this, args);\r\n  }\r\n  toJSON() {\r\n    return this.get();\r\n  }\r\n  observerAdded(count) {\r\n    if (count == 1)\r\n      this._attach();\r\n  }\r\n  observerRemoved(count) {\r\n    if (count == 0)\r\n      this._detach();\r\n  }\r\n  _attach() {\r\n  }\r\n  _detach() {\r\n  }\r\n  _onChange(value, idle = false) {\r\n    callFluidObservers(this, {\r\n      type: \"change\",\r\n      parent: this,\r\n      value,\r\n      idle\r\n    });\r\n  }\r\n  _onPriorityChange(priority) {\r\n    if (!this.idle) {\r\n      frameLoop.sort(this);\r\n    }\r\n    callFluidObservers(this, {\r\n      type: \"priority\",\r\n      parent: this,\r\n      priority\r\n    });\r\n  }\r\n}\r\n\r\nconst $P = Symbol.for(\"SpringPhase\");\r\nconst HAS_ANIMATED = 1;\r\nconst IS_ANIMATING = 2;\r\nconst IS_PAUSED = 4;\r\nconst hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;\r\nconst isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;\r\nconst isPaused = (target) => (target[$P] & IS_PAUSED) > 0;\r\nconst setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;\r\nconst setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;\r\n\r\nclass SpringValue extends FrameValue {\r\n  constructor(arg1, arg2) {\r\n    super();\r\n    this.animation = new Animation();\r\n    this.defaultProps = {};\r\n    this._state = {\r\n      paused: false,\r\n      pauseQueue: new Set(),\r\n      resumeQueue: new Set(),\r\n      timeouts: new Set()\r\n    };\r\n    this._pendingCalls = new Set();\r\n    this._lastCallId = 0;\r\n    this._lastToId = 0;\r\n    if (!is.und(arg1) || !is.und(arg2)) {\r\n      const props = is.obj(arg1) ? {...arg1} : {...arg2, from: arg1};\r\n      if (is.und(props.default)) {\r\n        props.default = true;\r\n      }\r\n      this.start(props);\r\n    }\r\n  }\r\n  get idle() {\r\n    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);\r\n  }\r\n  get goal() {\r\n    return getFluidValue(this.animation.to);\r\n  }\r\n  get velocity() {\r\n    const node = getAnimated(this);\r\n    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);\r\n  }\r\n  get hasAnimated() {\r\n    return hasAnimated(this);\r\n  }\r\n  get isAnimating() {\r\n    return isAnimating(this);\r\n  }\r\n  get isPaused() {\r\n    return isPaused(this);\r\n  }\r\n  advance(dt) {\r\n    let idle = true;\r\n    let changed = false;\r\n    const anim = this.animation;\r\n    let {config, toValues} = anim;\r\n    const payload = getPayload(anim.to);\r\n    if (!payload && hasFluidValue(anim.to)) {\r\n      toValues = toArray(getFluidValue(anim.to));\r\n    }\r\n    anim.values.forEach((node2, i) => {\r\n      if (node2.done)\r\n        return;\r\n      const to = node2.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i];\r\n      let finished = anim.immediate;\r\n      let position = to;\r\n      if (!finished) {\r\n        position = node2.lastPosition;\r\n        if (config.tension <= 0) {\r\n          node2.done = true;\r\n          return;\r\n        }\r\n        const elapsed = node2.elapsedTime += dt;\r\n        const from = anim.fromValues[i];\r\n        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\r\n        let velocity;\r\n        if (!is.und(config.duration)) {\r\n          let p = 1;\r\n          if (config.duration > 0) {\r\n            p = (config.progress || 0) + elapsed / config.duration;\r\n            p = p > 1 ? 1 : p < 0 ? 0 : p;\r\n          }\r\n          position = from + config.easing(p) * (to - from);\r\n          velocity = (position - node2.lastPosition) / dt;\r\n          finished = p == 1;\r\n        } else if (config.decay) {\r\n          const decay = config.decay === true ? 0.998 : config.decay;\r\n          const e = Math.exp(-(1 - decay) * elapsed);\r\n          position = from + v0 / (1 - decay) * (1 - e);\r\n          finished = Math.abs(node2.lastPosition - position) < 0.1;\r\n          velocity = v0 * e;\r\n        } else {\r\n          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;\r\n          const precision = config.precision || (from == to ? 5e-3 : Math.min(1, Math.abs(to - from) * 1e-3));\r\n          const restVelocity = config.restVelocity || precision / 10;\r\n          const bounceFactor = config.clamp ? 0 : config.bounce;\r\n          const canBounce = !is.und(bounceFactor);\r\n          const isGrowing = from == to ? node2.v0 > 0 : from < to;\r\n          let isMoving;\r\n          let isBouncing = false;\r\n          const step = 1;\r\n          const numSteps = Math.ceil(dt / step);\r\n          for (let n = 0; n < numSteps; ++n) {\r\n            isMoving = Math.abs(velocity) > restVelocity;\r\n            if (!isMoving) {\r\n              finished = Math.abs(to - position) <= precision;\r\n              if (finished) {\r\n                break;\r\n              }\r\n            }\r\n            if (canBounce) {\r\n              isBouncing = position == to || position > to == isGrowing;\r\n              if (isBouncing) {\r\n                velocity = -velocity * bounceFactor;\r\n                position = to;\r\n              }\r\n            }\r\n            const springForce = -config.tension * 1e-6 * (position - to);\r\n            const dampingForce = -config.friction * 1e-3 * velocity;\r\n            const acceleration = (springForce + dampingForce) / config.mass;\r\n            velocity = velocity + acceleration * step;\r\n            position = position + velocity * step;\r\n          }\r\n        }\r\n        node2.lastVelocity = velocity;\r\n        if (Number.isNaN(position)) {\r\n          console.warn(`Got NaN while animating:`, this);\r\n          finished = true;\r\n        }\r\n      }\r\n      if (payload && !payload[i].done) {\r\n        finished = false;\r\n      }\r\n      if (finished) {\r\n        node2.done = true;\r\n      } else {\r\n        idle = false;\r\n      }\r\n      if (node2.setValue(position, config.round)) {\r\n        changed = true;\r\n      }\r\n    });\r\n    const node = getAnimated(this);\r\n    if (idle) {\r\n      const value = getFluidValue(anim.to);\r\n      if (node.setValue(value) || changed) {\r\n        this._onChange(value);\r\n      }\r\n      this._stop();\r\n    } else if (changed) {\r\n      this._onChange(node.getValue());\r\n    }\r\n  }\r\n  set(value) {\r\n    raf.batchedUpdates(() => {\r\n      this._stop();\r\n      this._focus(value);\r\n      this._set(value);\r\n    });\r\n    return this;\r\n  }\r\n  pause() {\r\n    this._update({pause: true});\r\n  }\r\n  resume() {\r\n    this._update({pause: false});\r\n  }\r\n  finish() {\r\n    if (isAnimating(this)) {\r\n      const {to, config} = this.animation;\r\n      raf.batchedUpdates(() => {\r\n        this._onStart();\r\n        if (!config.decay) {\r\n          this._set(to, false);\r\n        }\r\n        this._stop();\r\n      });\r\n    }\r\n    return this;\r\n  }\r\n  update(props) {\r\n    const queue = this.queue || (this.queue = []);\r\n    queue.push(props);\r\n    return this;\r\n  }\r\n  start(to, arg2) {\r\n    let queue;\r\n    if (!is.und(to)) {\r\n      queue = [is.obj(to) ? to : {...arg2, to}];\r\n    } else {\r\n      queue = this.queue || [];\r\n      this.queue = [];\r\n    }\r\n    return Promise.all(queue.map((props) => this._update(props))).then((results) => getCombinedResult(this, results));\r\n  }\r\n  stop(cancel) {\r\n    const {to} = this.animation;\r\n    this._focus(this.get());\r\n    stopAsync(this._state, cancel && this._lastCallId);\r\n    raf.batchedUpdates(() => this._stop(to, cancel));\r\n    return this;\r\n  }\r\n  reset() {\r\n    this._update({reset: true});\r\n  }\r\n  eventObserved(event) {\r\n    if (event.type == \"change\") {\r\n      this._start();\r\n    } else if (event.type == \"priority\") {\r\n      this.priority = event.priority + 1;\r\n    }\r\n  }\r\n  _prepareNode(props) {\r\n    const key = this.key || \"\";\r\n    let {to, from} = props;\r\n    to = is.obj(to) ? to[key] : to;\r\n    if (to == null || isAsyncTo(to)) {\r\n      to = void 0;\r\n    }\r\n    from = is.obj(from) ? from[key] : from;\r\n    if (from == null) {\r\n      from = void 0;\r\n    }\r\n    const range = {to, from};\r\n    if (!hasAnimated(this)) {\r\n      if (props.reverse)\r\n        [to, from] = [from, to];\r\n      from = getFluidValue(from);\r\n      if (!is.und(from)) {\r\n        this._set(from);\r\n      } else if (!getAnimated(this)) {\r\n        this._set(to);\r\n      }\r\n    }\r\n    return range;\r\n  }\r\n  _update({...props}, isLoop) {\r\n    const {key, defaultProps} = this;\r\n    if (props.default)\r\n      Object.assign(defaultProps, getDefaultProps(props, (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value));\r\n    mergeActiveFn(this, props, \"onProps\");\r\n    sendEvent(this, \"onProps\", props, this);\r\n    const range = this._prepareNode(props);\r\n    if (Object.isFrozen(this)) {\r\n      throw Error(\"Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?\");\r\n    }\r\n    const state = this._state;\r\n    return scheduleProps(++this._lastCallId, {\r\n      key,\r\n      props,\r\n      defaultProps,\r\n      state,\r\n      actions: {\r\n        pause: () => {\r\n          if (!isPaused(this)) {\r\n            setPausedBit(this, true);\r\n            flushCalls(state.pauseQueue);\r\n            sendEvent(this, \"onPause\", this);\r\n          }\r\n        },\r\n        resume: () => {\r\n          if (isPaused(this)) {\r\n            setPausedBit(this, false);\r\n            if (isAnimating(this)) {\r\n              this._resume();\r\n            }\r\n            flushCalls(state.resumeQueue);\r\n            sendEvent(this, \"onResume\", this);\r\n          }\r\n        },\r\n        start: this._merge.bind(this, range)\r\n      }\r\n    }).then((result) => {\r\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\r\n        const nextProps = createLoopUpdate(props);\r\n        if (nextProps) {\r\n          return this._update(nextProps, true);\r\n        }\r\n      }\r\n      return result;\r\n    });\r\n  }\r\n  _merge(range, props, resolve) {\r\n    if (props.cancel) {\r\n      this.stop(true);\r\n      return resolve(getCancelledResult(this));\r\n    }\r\n    const hasToProp = !is.und(range.to);\r\n    const hasFromProp = !is.und(range.from);\r\n    if (hasToProp || hasFromProp) {\r\n      if (props.callId > this._lastToId) {\r\n        this._lastToId = props.callId;\r\n      } else {\r\n        return resolve(getCancelledResult(this));\r\n      }\r\n    }\r\n    const {key, defaultProps, animation: anim} = this;\r\n    const {to: prevTo, from: prevFrom} = anim;\r\n    let {to = prevTo, from = prevFrom} = range;\r\n    if (hasFromProp && !hasToProp && (!props.default || is.und(to))) {\r\n      to = from;\r\n    }\r\n    if (props.reverse)\r\n      [to, from] = [from, to];\r\n    const hasFromChanged = !isEqual(from, prevFrom);\r\n    if (hasFromChanged) {\r\n      anim.from = from;\r\n    }\r\n    from = getFluidValue(from);\r\n    const hasToChanged = !isEqual(to, prevTo);\r\n    if (hasToChanged) {\r\n      this._focus(to);\r\n    }\r\n    const hasAsyncTo = isAsyncTo(props.to);\r\n    const {config} = anim;\r\n    const {decay, velocity} = config;\r\n    if (hasToProp || hasFromProp) {\r\n      config.velocity = 0;\r\n    }\r\n    if (props.config && !hasAsyncTo) {\r\n      mergeConfig(config, callProp(props.config, key), props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);\r\n    }\r\n    let node = getAnimated(this);\r\n    if (!node || is.und(to)) {\r\n      return resolve(getFinishedResult(this, true));\r\n    }\r\n    const reset = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key);\r\n    const value = reset ? from : this.get();\r\n    const goal = computeGoal(to);\r\n    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);\r\n    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\r\n    if (hasToChanged) {\r\n      const nodeType = getAnimatedType(to);\r\n      if (nodeType !== node.constructor) {\r\n        if (immediate) {\r\n          node = this._set(goal);\r\n        } else\r\n          throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the \"to\" prop suggests`);\r\n      }\r\n    }\r\n    const goalType = node.constructor;\r\n    let started = hasFluidValue(to);\r\n    let finished = false;\r\n    if (!started) {\r\n      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;\r\n      if (hasToChanged || hasValueChanged) {\r\n        finished = isEqual(computeGoal(value), goal);\r\n        started = !finished;\r\n      }\r\n      if (!isEqual(config.decay, decay) || !isEqual(config.velocity, velocity)) {\r\n        started = true;\r\n      }\r\n    }\r\n    if (finished && isAnimating(this)) {\r\n      if (anim.changed && !reset) {\r\n        started = true;\r\n      } else if (!started) {\r\n        this._stop(prevTo);\r\n      }\r\n    }\r\n    if (!hasAsyncTo) {\r\n      if (started || hasFluidValue(prevTo)) {\r\n        anim.values = node.getPayload();\r\n        anim.toValues = hasFluidValue(to) ? null : goalType == AnimatedString ? [1] : toArray(goal);\r\n      }\r\n      if (anim.immediate != immediate) {\r\n        anim.immediate = immediate;\r\n        if (!immediate && !reset) {\r\n          this._set(prevTo);\r\n        }\r\n      }\r\n      if (started) {\r\n        const {onRest} = anim;\r\n        each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));\r\n        const result = getFinishedResult(this, checkFinished(this, prevTo));\r\n        flushCalls(this._pendingCalls, result);\r\n        this._pendingCalls.add(resolve);\r\n        if (anim.changed)\r\n          raf.batchedUpdates(() => {\r\n            var _a;\r\n            anim.changed = !reset;\r\n            onRest == null ? void 0 : onRest(result);\r\n            if (reset) {\r\n              callProp(defaultProps.onRest, result);\r\n            } else {\r\n              (_a = anim.onStart) == null ? void 0 : _a.call(anim, this);\r\n            }\r\n          });\r\n      }\r\n    }\r\n    if (reset) {\r\n      this._set(value);\r\n    }\r\n    if (hasAsyncTo) {\r\n      resolve(runAsync(props.to, props, this._state, this));\r\n    } else if (started) {\r\n      this._start();\r\n    } else if (isAnimating(this) && !hasToChanged) {\r\n      this._pendingCalls.add(resolve);\r\n    } else {\r\n      resolve(getNoopResult(this, value));\r\n    }\r\n  }\r\n  _focus(value) {\r\n    const anim = this.animation;\r\n    if (value !== anim.to) {\r\n      if (getFluidObservers(this)) {\r\n        this._detach();\r\n      }\r\n      anim.to = value;\r\n      if (getFluidObservers(this)) {\r\n        this._attach();\r\n      }\r\n    }\r\n  }\r\n  _attach() {\r\n    let priority = 0;\r\n    const {to} = this.animation;\r\n    if (hasFluidValue(to)) {\r\n      addFluidObserver(to, this);\r\n      if (isFrameValue(to)) {\r\n        priority = to.priority + 1;\r\n      }\r\n    }\r\n    this.priority = priority;\r\n  }\r\n  _detach() {\r\n    const {to} = this.animation;\r\n    if (hasFluidValue(to)) {\r\n      removeFluidObserver(to, this);\r\n    }\r\n  }\r\n  _set(arg, idle = true) {\r\n    const value = getFluidValue(arg);\r\n    if (!is.und(value)) {\r\n      const oldNode = getAnimated(this);\r\n      if (!oldNode || !isEqual(value, oldNode.getValue())) {\r\n        const nodeType = getAnimatedType(value);\r\n        if (!oldNode || oldNode.constructor != nodeType) {\r\n          setAnimated(this, nodeType.create(value));\r\n        } else {\r\n          oldNode.setValue(value);\r\n        }\r\n        if (oldNode) {\r\n          raf.batchedUpdates(() => {\r\n            this._onChange(value, idle);\r\n          });\r\n        }\r\n      }\r\n    }\r\n    return getAnimated(this);\r\n  }\r\n  _onStart() {\r\n    const anim = this.animation;\r\n    if (!anim.changed) {\r\n      anim.changed = true;\r\n      sendEvent(this, \"onStart\", this);\r\n    }\r\n  }\r\n  _onChange(value, idle) {\r\n    if (!idle) {\r\n      this._onStart();\r\n      callProp(this.animation.onChange, value, this);\r\n    }\r\n    callProp(this.defaultProps.onChange, value, this);\r\n    super._onChange(value, idle);\r\n  }\r\n  _start() {\r\n    const anim = this.animation;\r\n    getAnimated(this).reset(getFluidValue(anim.to));\r\n    if (!anim.immediate) {\r\n      anim.fromValues = anim.values.map((node) => node.lastPosition);\r\n    }\r\n    if (!isAnimating(this)) {\r\n      setActiveBit(this, true);\r\n      if (!isPaused(this)) {\r\n        this._resume();\r\n      }\r\n    }\r\n  }\r\n  _resume() {\r\n    if (Globals.skipAnimation) {\r\n      this.finish();\r\n    } else {\r\n      frameLoop.start(this);\r\n    }\r\n  }\r\n  _stop(goal, cancel) {\r\n    if (isAnimating(this)) {\r\n      setActiveBit(this, false);\r\n      const anim = this.animation;\r\n      each(anim.values, (node) => {\r\n        node.done = true;\r\n      });\r\n      if (anim.toValues) {\r\n        anim.onChange = anim.onPause = anim.onResume = void 0;\r\n      }\r\n      callFluidObservers(this, {\r\n        type: \"idle\",\r\n        parent: this\r\n      });\r\n      const result = cancel ? getCancelledResult(this) : getFinishedResult(this, checkFinished(this, goal != null ? goal : anim.to));\r\n      flushCalls(this._pendingCalls, result);\r\n      if (anim.changed) {\r\n        anim.changed = false;\r\n        sendEvent(this, \"onRest\", result);\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction checkFinished(target, to) {\r\n  const goal = computeGoal(to);\r\n  const value = computeGoal(target.get());\r\n  return isEqual(value, goal);\r\n}\r\nfunction createLoopUpdate(props, loop = props.loop, to = props.to) {\r\n  let loopRet = callProp(loop);\r\n  if (loopRet) {\r\n    const overrides = loopRet !== true && inferTo(loopRet);\r\n    const reverse = (overrides || props).reverse;\r\n    const reset = !overrides || overrides.reset;\r\n    return createUpdate({\r\n      ...props,\r\n      loop,\r\n      default: false,\r\n      pause: void 0,\r\n      to: !reverse || isAsyncTo(to) ? to : void 0,\r\n      from: reset ? props.from : void 0,\r\n      reset,\r\n      ...overrides\r\n    });\r\n  }\r\n}\r\nfunction createUpdate(props) {\r\n  const {to, from} = props = inferTo(props);\r\n  const keys = new Set();\r\n  if (is.obj(to))\r\n    findDefined(to, keys);\r\n  if (is.obj(from))\r\n    findDefined(from, keys);\r\n  props.keys = keys.size ? Array.from(keys) : null;\r\n  return props;\r\n}\r\nfunction declareUpdate(props) {\r\n  const update = createUpdate(props);\r\n  if (is.und(update.default)) {\r\n    update.default = getDefaultProps(update);\r\n  }\r\n  return update;\r\n}\r\nfunction findDefined(values, keys) {\r\n  eachProp(values, (value, key) => value != null && keys.add(key));\r\n}\r\nconst ACTIVE_EVENTS = [\r\n  \"onStart\",\r\n  \"onRest\",\r\n  \"onChange\",\r\n  \"onPause\",\r\n  \"onResume\"\r\n];\r\nfunction mergeActiveFn(target, props, type) {\r\n  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;\r\n}\r\nfunction sendEvent(target, type, ...args) {\r\n  var _a, _b, _c, _d;\r\n  (_b = (_a = target.animation)[type]) == null ? void 0 : _b.call(_a, ...args);\r\n  (_d = (_c = target.defaultProps)[type]) == null ? void 0 : _d.call(_c, ...args);\r\n}\r\n\r\nconst BATCHED_EVENTS = [\"onStart\", \"onChange\", \"onRest\"];\r\nlet nextId$1 = 1;\r\nclass Controller {\r\n  constructor(props, flush2) {\r\n    this.id = nextId$1++;\r\n    this.springs = {};\r\n    this.queue = [];\r\n    this._lastAsyncId = 0;\r\n    this._active = new Set();\r\n    this._changed = new Set();\r\n    this._started = false;\r\n    this._state = {\r\n      paused: false,\r\n      pauseQueue: new Set(),\r\n      resumeQueue: new Set(),\r\n      timeouts: new Set()\r\n    };\r\n    this._events = {\r\n      onStart: new Set(),\r\n      onChange: new Set(),\r\n      onRest: new Map()\r\n    };\r\n    this._onFrame = this._onFrame.bind(this);\r\n    if (flush2) {\r\n      this._flush = flush2;\r\n    }\r\n    if (props) {\r\n      this.start({default: true, ...props});\r\n    }\r\n  }\r\n  get idle() {\r\n    return !this._state.asyncTo && Object.values(this.springs).every((spring) => spring.idle);\r\n  }\r\n  get() {\r\n    const values = {};\r\n    this.each((spring, key) => values[key] = spring.get());\r\n    return values;\r\n  }\r\n  set(values) {\r\n    for (const key in values) {\r\n      const value = values[key];\r\n      if (!is.und(value)) {\r\n        this.springs[key].set(value);\r\n      }\r\n    }\r\n  }\r\n  update(props) {\r\n    if (props) {\r\n      this.queue.push(createUpdate(props));\r\n    }\r\n    return this;\r\n  }\r\n  start(props) {\r\n    let {queue} = this;\r\n    if (props) {\r\n      queue = toArray(props).map(createUpdate);\r\n    } else {\r\n      this.queue = [];\r\n    }\r\n    if (this._flush) {\r\n      return this._flush(this, queue);\r\n    }\r\n    prepareKeys(this, queue);\r\n    return flushUpdateQueue(this, queue);\r\n  }\r\n  stop(arg, keys) {\r\n    if (arg !== !!arg) {\r\n      keys = arg;\r\n    }\r\n    if (keys) {\r\n      const springs = this.springs;\r\n      each(toArray(keys), (key) => springs[key].stop(!!arg));\r\n    } else {\r\n      stopAsync(this._state, this._lastAsyncId);\r\n      this.each((spring) => spring.stop(!!arg));\r\n    }\r\n    return this;\r\n  }\r\n  pause(keys) {\r\n    if (is.und(keys)) {\r\n      this.start({pause: true});\r\n    } else {\r\n      const springs = this.springs;\r\n      each(toArray(keys), (key) => springs[key].pause());\r\n    }\r\n    return this;\r\n  }\r\n  resume(keys) {\r\n    if (is.und(keys)) {\r\n      this.start({pause: false});\r\n    } else {\r\n      const springs = this.springs;\r\n      each(toArray(keys), (key) => springs[key].resume());\r\n    }\r\n    return this;\r\n  }\r\n  each(iterator) {\r\n    eachProp(this.springs, iterator);\r\n  }\r\n  _onFrame() {\r\n    const {onStart, onChange, onRest} = this._events;\r\n    const active = this._active.size > 0;\r\n    if (active && !this._started) {\r\n      this._started = true;\r\n      flushCalls(onStart, this);\r\n    }\r\n    const idle = !active && this._started;\r\n    const changed = this._changed.size > 0 && onChange.size;\r\n    const values = changed || idle && onRest.size ? this.get() : null;\r\n    if (changed) {\r\n      flushCalls(onChange, values);\r\n    }\r\n    if (idle) {\r\n      this._started = false;\r\n      flush(onRest, ([onRest2, result]) => {\r\n        result.value = values;\r\n        onRest2(result);\r\n      });\r\n    }\r\n  }\r\n  eventObserved(event) {\r\n    if (event.type == \"change\") {\r\n      this._changed.add(event.parent);\r\n      if (!event.idle) {\r\n        this._active.add(event.parent);\r\n      }\r\n    } else if (event.type == \"idle\") {\r\n      this._active.delete(event.parent);\r\n    } else\r\n      return;\r\n    raf.onFrame(this._onFrame);\r\n  }\r\n}\r\nfunction flushUpdateQueue(ctrl, queue) {\r\n  return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then((results) => getCombinedResult(ctrl, results));\r\n}\r\nasync function flushUpdate(ctrl, props, isLoop) {\r\n  const {keys, to, from, loop, onRest, onResolve} = props;\r\n  const defaults = is.obj(props.default) && props.default;\r\n  if (loop) {\r\n    props.loop = false;\r\n  }\r\n  if (to === false)\r\n    props.to = null;\r\n  if (from === false)\r\n    props.from = null;\r\n  const asyncTo = is.arr(to) || is.fun(to) ? to : void 0;\r\n  if (asyncTo) {\r\n    props.to = void 0;\r\n    props.onRest = void 0;\r\n    if (defaults) {\r\n      defaults.onRest = void 0;\r\n    }\r\n  } else {\r\n    each(BATCHED_EVENTS, (key) => {\r\n      const handler = props[key];\r\n      if (is.fun(handler)) {\r\n        const queue = ctrl[\"_events\"][key];\r\n        if (queue instanceof Set) {\r\n          props[key] = () => queue.add(handler);\r\n        } else {\r\n          props[key] = ({finished, cancelled}) => {\r\n            const result2 = queue.get(handler);\r\n            if (result2) {\r\n              if (!finished)\r\n                result2.finished = false;\r\n              if (cancelled)\r\n                result2.cancelled = true;\r\n            } else {\r\n              queue.set(handler, {\r\n                target: ctrl,\r\n                value: null,\r\n                finished,\r\n                cancelled\r\n              });\r\n            }\r\n          };\r\n        }\r\n        if (defaults) {\r\n          defaults[key] = props[key];\r\n        }\r\n      }\r\n    });\r\n  }\r\n  const state = ctrl[\"_state\"];\r\n  if (props.pause === !state.paused) {\r\n    state.paused = props.pause;\r\n    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);\r\n  } else if (state.paused) {\r\n    props.pause = true;\r\n  }\r\n  const promises = (keys || Object.keys(ctrl.springs)).map((key) => ctrl.springs[key].start(props));\r\n  const cancel = props.cancel === true || getDefaultProp(props, \"cancel\") === true;\r\n  if (asyncTo || cancel && state.asyncId) {\r\n    promises.push(scheduleProps(++ctrl[\"_lastAsyncId\"], {\r\n      props,\r\n      state,\r\n      actions: {\r\n        pause: noop,\r\n        resume: noop,\r\n        start(props2, resolve) {\r\n          if (cancel) {\r\n            stopAsync(state, ctrl[\"_lastAsyncId\"]);\r\n            resolve(getCancelledResult(ctrl));\r\n          } else {\r\n            props2.onRest = onRest;\r\n            resolve(runAsync(asyncTo, props2, state, ctrl));\r\n          }\r\n        }\r\n      }\r\n    }));\r\n  }\r\n  if (state.paused) {\r\n    await new Promise((resume) => {\r\n      state.resumeQueue.add(resume);\r\n    });\r\n  }\r\n  const result = getCombinedResult(ctrl, await Promise.all(promises));\r\n  if (loop && result.finished && !(isLoop && result.noop)) {\r\n    const nextProps = createLoopUpdate(props, loop, to);\r\n    if (nextProps) {\r\n      prepareKeys(ctrl, [nextProps]);\r\n      return flushUpdate(ctrl, nextProps, true);\r\n    }\r\n  }\r\n  if (onResolve) {\r\n    raf.batchedUpdates(() => onResolve(result));\r\n  }\r\n  return result;\r\n}\r\nfunction getSprings(ctrl, props) {\r\n  const springs = {...ctrl.springs};\r\n  if (props) {\r\n    each(toArray(props), (props2) => {\r\n      if (is.und(props2.keys)) {\r\n        props2 = createUpdate(props2);\r\n      }\r\n      if (!is.obj(props2.to)) {\r\n        props2 = {...props2, to: void 0};\r\n      }\r\n      prepareSprings(springs, props2, (key) => {\r\n        return createSpring(key);\r\n      });\r\n    });\r\n  }\r\n  return springs;\r\n}\r\nfunction setSprings(ctrl, springs) {\r\n  eachProp(springs, (spring, key) => {\r\n    if (!ctrl.springs[key]) {\r\n      ctrl.springs[key] = spring;\r\n      addFluidObserver(spring, ctrl);\r\n    }\r\n  });\r\n}\r\nfunction createSpring(key, observer) {\r\n  const spring = new SpringValue();\r\n  spring.key = key;\r\n  if (observer) {\r\n    addFluidObserver(spring, observer);\r\n  }\r\n  return spring;\r\n}\r\nfunction prepareSprings(springs, props, create) {\r\n  if (props.keys) {\r\n    each(props.keys, (key) => {\r\n      const spring = springs[key] || (springs[key] = create(key));\r\n      spring[\"_prepareNode\"](props);\r\n    });\r\n  }\r\n}\r\nfunction prepareKeys(ctrl, queue) {\r\n  each(queue, (props) => {\r\n    prepareSprings(ctrl.springs, props, (key) => {\r\n      return createSpring(key, ctrl);\r\n    });\r\n  });\r\n}\r\n\r\nconst SpringContext = ({\r\n  children,\r\n  ...props\r\n}) => {\r\n  const inherited = useContext(ctx);\r\n  const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;\r\n  props = useMemoOne(() => ({pause, immediate}), [pause, immediate]);\r\n  const {Provider} = ctx;\r\n  return /* @__PURE__ */ createElement(Provider, {\r\n    value: props\r\n  }, children);\r\n};\r\nconst ctx = makeContext(SpringContext, {});\r\nSpringContext.Provider = ctx.Provider;\r\nSpringContext.Consumer = ctx.Consumer;\r\nfunction makeContext(target, init) {\r\n  Object.assign(target, createContext(init));\r\n  target.Provider._context = target;\r\n  target.Consumer._context = target;\r\n  return target;\r\n}\r\n\r\nclass SpringRef {\r\n  constructor() {\r\n    this.current = [];\r\n  }\r\n  set(values) {\r\n    each(this.current, (ctrl) => ctrl.set(values));\r\n  }\r\n  start(props) {\r\n    const results = [];\r\n    each(this.current, (ctrl, i) => {\r\n      if (is.und(props)) {\r\n        results.push(ctrl.start());\r\n      } else {\r\n        const update = this._getProps(props, ctrl, i);\r\n        if (update) {\r\n          results.push(ctrl.start(update));\r\n        }\r\n      }\r\n    });\r\n    return results;\r\n  }\r\n  update(props) {\r\n    each(this.current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));\r\n    return this;\r\n  }\r\n  add(ctrl) {\r\n    if (!this.current.includes(ctrl)) {\r\n      this.current.push(ctrl);\r\n    }\r\n  }\r\n  delete(ctrl) {\r\n    const i = this.current.indexOf(ctrl);\r\n    if (~i)\r\n      this.current.splice(i, 1);\r\n  }\r\n  _getProps(arg, ctrl, index) {\r\n    return is.fun(arg) ? arg(index, ctrl) : arg;\r\n  }\r\n}\r\neach([\"stop\", \"pause\", \"resume\"], (key) => {\r\n  SpringRef.prototype[key] = function() {\r\n    each(this.current, (ctrl) => ctrl[key](...arguments));\r\n    return this;\r\n  };\r\n});\r\n\r\nfunction useSprings(length, props, deps) {\r\n  const propsFn = is.fun(props) && props;\r\n  if (propsFn && !deps)\r\n    deps = [];\r\n  const ref = useMemo(() => propsFn || arguments.length == 3 ? new SpringRef() : void 0, []);\r\n  const layoutId = useRef(0);\r\n  const forceUpdate = useForceUpdate();\r\n  const state = useMemo(() => ({\r\n    ctrls: [],\r\n    queue: [],\r\n    flush(ctrl, updates2) {\r\n      const springs2 = getSprings(ctrl, updates2);\r\n      const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);\r\n      return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {\r\n        setSprings(ctrl, springs2);\r\n        state.queue.push(() => {\r\n          resolve(flushUpdateQueue(ctrl, updates2));\r\n        });\r\n        forceUpdate();\r\n      });\r\n    }\r\n  }), []);\r\n  const ctrls = [...state.ctrls];\r\n  const updates = [];\r\n  const prevLength = usePrev(length) || 0;\r\n  const oldCtrls = ctrls.slice(length, prevLength);\r\n  useMemo(() => {\r\n    ctrls.length = length;\r\n    declareUpdates(prevLength, length);\r\n  }, [length]);\r\n  useMemo(() => {\r\n    declareUpdates(0, Math.min(prevLength, length));\r\n  }, deps);\r\n  function declareUpdates(startIndex, endIndex) {\r\n    for (let i = startIndex; i < endIndex; i++) {\r\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller(null, state.flush));\r\n      const update = propsFn ? propsFn(i, ctrl) : props[i];\r\n      if (update) {\r\n        updates[i] = declareUpdate(update);\r\n      }\r\n    }\r\n  }\r\n  const springs = ctrls.map((ctrl, i) => getSprings(ctrl, updates[i]));\r\n  const context = useContext(SpringContext);\r\n  const prevContext = usePrev(context);\r\n  const hasContext = context !== prevContext && hasProps(context);\r\n  useLayoutEffect(() => {\r\n    layoutId.current++;\r\n    state.ctrls = ctrls;\r\n    const {queue} = state;\r\n    if (queue.length) {\r\n      state.queue = [];\r\n      each(queue, (cb) => cb());\r\n    }\r\n    each(oldCtrls, (ctrl) => {\r\n      detachRefs(ctrl, ref);\r\n      ctrl.stop(true);\r\n    });\r\n    each(ctrls, (ctrl, i) => {\r\n      const values2 = springs[i];\r\n      setSprings(ctrl, values2);\r\n      ref == null ? void 0 : ref.add(ctrl);\r\n      if (hasContext) {\r\n        ctrl.start({default: context});\r\n      }\r\n      const update = updates[i];\r\n      if (update) {\r\n        replaceRef(ctrl, update.ref);\r\n        if (ctrl.ref) {\r\n          ctrl.queue.push(update);\r\n        } else {\r\n          ctrl.start(update);\r\n        }\r\n      }\r\n    });\r\n  });\r\n  useOnce(() => () => {\r\n    each(state.ctrls, (ctrl) => ctrl.stop(true));\r\n  });\r\n  const values = springs.map((x) => ({...x}));\r\n  return ref ? [values, ref] : values;\r\n}\r\n\r\nfunction useSpring(props, deps) {\r\n  const isFn = is.fun(props);\r\n  const [[values], ref] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);\r\n  return isFn || arguments.length == 2 ? [values, ref] : values;\r\n}\r\n\r\nconst initSpringRef = () => new SpringRef();\r\nconst useSpringRef = () => useState(initSpringRef)[0];\r\n\r\nfunction useTrail(length, propsArg, deps) {\r\n  const propsFn = is.fun(propsArg) && propsArg;\r\n  if (propsFn && !deps)\r\n    deps = [];\r\n  let reverse = true;\r\n  const result = useSprings(length, (i, ctrl) => {\r\n    const props = propsFn ? propsFn(i, ctrl) : propsArg;\r\n    reverse = reverse && props.reverse;\r\n    return props;\r\n  }, deps || [{}]);\r\n  const ref = result[1];\r\n  useLayoutEffect(() => {\r\n    each(ref.current, (ctrl, i) => {\r\n      const parent = ref.current[i + (reverse ? 1 : -1)];\r\n      if (parent)\r\n        ctrl.start({to: parent.springs});\r\n    });\r\n  }, deps);\r\n  if (propsFn || arguments.length == 3) {\r\n    ref[\"_getProps\"] = (propsArg2, ctrl, i) => {\r\n      const props = is.fun(propsArg2) ? propsArg2(i, ctrl) : propsArg2;\r\n      if (props) {\r\n        const parent = ref.current[i + (props.reverse ? 1 : -1)];\r\n        if (parent)\r\n          props.to = parent.springs;\r\n        return props;\r\n      }\r\n    };\r\n    return result;\r\n  }\r\n  return result[0];\r\n}\r\n\r\nconst MOUNT = \"mount\";\r\nconst ENTER = \"enter\";\r\nconst UPDATE = \"update\";\r\nconst LEAVE = \"leave\";\r\n\r\nfunction useTransition(data, props, deps) {\r\n  const {reset, sort, trail = 0, expires = true, onDestroyed} = props;\r\n  const ref = useMemo(() => arguments.length == 3 ? new SpringRef() : void 0, []);\r\n  const items = toArray(data);\r\n  const transitions = [];\r\n  const usedTransitions = useRef(null);\r\n  const prevTransitions = reset ? null : usedTransitions.current;\r\n  useLayoutEffect(() => {\r\n    usedTransitions.current = transitions;\r\n  });\r\n  useOnce(() => () => each(usedTransitions.current, (t) => {\r\n    if (t.expired) {\r\n      clearTimeout(t.expirationId);\r\n    }\r\n    detachRefs(t.ctrl, ref);\r\n    t.ctrl.stop(true);\r\n  }));\r\n  const keys = getKeys(items, props, prevTransitions);\r\n  const expired = reset && usedTransitions.current || [];\r\n  useLayoutEffect(() => each(expired, ({ctrl, item, key}) => {\r\n    detachRefs(ctrl, ref);\r\n    callProp(onDestroyed, item, key);\r\n  }));\r\n  const reused = [];\r\n  if (prevTransitions)\r\n    each(prevTransitions, (t, i) => {\r\n      if (t.expired) {\r\n        clearTimeout(t.expirationId);\r\n        expired.push(t);\r\n      } else {\r\n        i = reused[i] = keys.indexOf(t.key);\r\n        if (~i)\r\n          transitions[i] = t;\r\n      }\r\n    });\r\n  each(items, (item, i) => {\r\n    transitions[i] || (transitions[i] = {\r\n      key: keys[i],\r\n      item,\r\n      phase: MOUNT,\r\n      ctrl: new Controller()\r\n    });\r\n  });\r\n  if (reused.length) {\r\n    let i = -1;\r\n    each(reused, (keyIndex, prevIndex) => {\r\n      const t = prevTransitions[prevIndex];\r\n      if (~keyIndex) {\r\n        i = transitions.indexOf(t);\r\n        transitions[i] = {...t, item: items[keyIndex]};\r\n      } else if (props.leave) {\r\n        transitions.splice(++i, 0, t);\r\n      }\r\n    });\r\n  }\r\n  if (is.fun(sort)) {\r\n    transitions.sort((a, b) => sort(a.item, b.item));\r\n  }\r\n  let delay = -trail;\r\n  const forceUpdate = useForceUpdate();\r\n  const defaultProps = getDefaultProps(props);\r\n  const changes = new Map();\r\n  each(transitions, (t, i) => {\r\n    const key = t.key;\r\n    const prevPhase = t.phase;\r\n    let to;\r\n    let phase;\r\n    if (prevPhase == MOUNT) {\r\n      to = props.enter;\r\n      phase = ENTER;\r\n    } else {\r\n      const isLeave = keys.indexOf(key) < 0;\r\n      if (prevPhase != LEAVE) {\r\n        if (isLeave) {\r\n          to = props.leave;\r\n          phase = LEAVE;\r\n        } else if (to = props.update) {\r\n          phase = UPDATE;\r\n        } else\r\n          return;\r\n      } else if (!isLeave) {\r\n        to = props.enter;\r\n        phase = ENTER;\r\n      } else\r\n        return;\r\n    }\r\n    to = callProp(to, t.item, i);\r\n    to = is.obj(to) ? inferTo(to) : {to};\r\n    if (!to.config) {\r\n      const config = props.config || defaultProps.config;\r\n      to.config = callProp(config, t.item, i);\r\n    }\r\n    const payload = {\r\n      ...defaultProps,\r\n      delay: delay += trail,\r\n      reset: false,\r\n      ...to\r\n    };\r\n    if (phase == ENTER && is.und(payload.from)) {\r\n      const from = is.und(props.initial) || prevTransitions ? props.from : props.initial;\r\n      payload.from = callProp(from, t.item, i);\r\n    }\r\n    const {onResolve} = payload;\r\n    payload.onResolve = (result) => {\r\n      callProp(onResolve, result);\r\n      const transitions2 = usedTransitions.current;\r\n      const t2 = transitions2.find((t3) => t3.key === key);\r\n      if (!t2)\r\n        return;\r\n      if (result.cancelled && t2.phase != UPDATE) {\r\n        t2.phase = prevPhase;\r\n        return;\r\n      }\r\n      if (t2.ctrl.idle) {\r\n        const idle = transitions2.every((t3) => t3.ctrl.idle);\r\n        if (t2.phase == LEAVE) {\r\n          const expiry = callProp(expires, t2.item);\r\n          if (expiry !== false) {\r\n            const expiryMs = expiry === true ? 0 : expiry;\r\n            t2.expired = true;\r\n            if (!idle && expiryMs > 0) {\r\n              if (expiryMs <= 2147483647)\r\n                t2.expirationId = setTimeout(forceUpdate, expiryMs);\r\n              return;\r\n            }\r\n          }\r\n        }\r\n        if (idle && transitions2.some((t3) => t3.expired)) {\r\n          forceUpdate();\r\n        }\r\n      }\r\n    };\r\n    const springs = getSprings(t.ctrl, payload);\r\n    changes.set(t, {phase, springs, payload});\r\n  });\r\n  const context = useContext(SpringContext);\r\n  const prevContext = usePrev(context);\r\n  const hasContext = context !== prevContext && hasProps(context);\r\n  useLayoutEffect(() => {\r\n    if (hasContext)\r\n      each(transitions, (t) => {\r\n        t.ctrl.start({default: context});\r\n      });\r\n  }, [context]);\r\n  useLayoutEffect(() => {\r\n    each(changes, ({phase, springs, payload}, t) => {\r\n      const {ctrl} = t;\r\n      t.phase = phase;\r\n      ref == null ? void 0 : ref.add(ctrl);\r\n      replaceRef(ctrl, payload.ref);\r\n      setSprings(ctrl, springs);\r\n      if (hasContext && phase == ENTER) {\r\n        ctrl.start({default: context});\r\n      }\r\n      ctrl[ctrl.ref ? \"update\" : \"start\"](payload);\r\n    });\r\n  }, reset ? void 0 : deps);\r\n  const renderTransitions = (render) => /* @__PURE__ */ createElement(Fragment, null, transitions.map((t, i) => {\r\n    const {springs} = changes.get(t) || t.ctrl;\r\n    const elem = render({...springs}, t.item, t, i);\r\n    return elem && elem.type ? /* @__PURE__ */ createElement(elem.type, {\r\n      ...elem.props,\r\n      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\r\n      ref: elem.ref\r\n    }) : elem;\r\n  }));\r\n  return ref ? [renderTransitions, ref] : renderTransitions;\r\n}\r\nlet nextKey = 1;\r\nfunction getKeys(items, {key, keys = key}, prevTransitions) {\r\n  if (keys === null) {\r\n    const reused = new Set();\r\n    return items.map((item) => {\r\n      const t = prevTransitions && prevTransitions.find((t2) => t2.item === item && t2.phase !== LEAVE && !reused.has(t2));\r\n      if (t) {\r\n        reused.add(t);\r\n        return t.key;\r\n      }\r\n      return nextKey++;\r\n    });\r\n  }\r\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\r\n}\r\n\r\nfunction Spring({children, ...props}) {\r\n  return children(useSpring(props));\r\n}\r\n\r\nfunction Trail({\r\n  items,\r\n  children,\r\n  ...props\r\n}) {\r\n  const trails = useTrail(items.length, props);\r\n  return items.map((item, index) => {\r\n    const result = children(item, index);\r\n    return is.fun(result) ? result(trails[index]) : result;\r\n  });\r\n}\r\n\r\nfunction Transition({\r\n  items,\r\n  children,\r\n  ...props\r\n}) {\r\n  return useTransition(items, props)(children);\r\n}\r\n\r\nclass Interpolation extends FrameValue {\r\n  constructor(source, args) {\r\n    super();\r\n    this.source = source;\r\n    this.idle = true;\r\n    this._active = new Set();\r\n    this.calc = createInterpolator(...args);\r\n    const value = this._get();\r\n    const nodeType = getAnimatedType(value);\r\n    setAnimated(this, nodeType.create(value));\r\n  }\r\n  advance(_dt) {\r\n    const value = this._get();\r\n    const oldValue = this.get();\r\n    if (!isEqual(value, oldValue)) {\r\n      getAnimated(this).setValue(value);\r\n      this._onChange(value, this.idle);\r\n    }\r\n    if (!this.idle && checkIdle(this._active)) {\r\n      becomeIdle(this);\r\n    }\r\n  }\r\n  _get() {\r\n    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));\r\n    return this.calc(...inputs);\r\n  }\r\n  _start() {\r\n    if (this.idle && !checkIdle(this._active)) {\r\n      this.idle = false;\r\n      each(getPayload(this), (node) => {\r\n        node.done = false;\r\n      });\r\n      if (Globals.skipAnimation) {\r\n        raf.batchedUpdates(() => this.advance());\r\n        becomeIdle(this);\r\n      } else {\r\n        frameLoop.start(this);\r\n      }\r\n    }\r\n  }\r\n  _attach() {\r\n    let priority = 1;\r\n    each(toArray(this.source), (source) => {\r\n      if (hasFluidValue(source)) {\r\n        addFluidObserver(source, this);\r\n      }\r\n      if (isFrameValue(source)) {\r\n        if (!source.idle) {\r\n          this._active.add(source);\r\n        }\r\n        priority = Math.max(priority, source.priority + 1);\r\n      }\r\n    });\r\n    this.priority = priority;\r\n    this._start();\r\n  }\r\n  _detach() {\r\n    each(toArray(this.source), (source) => {\r\n      if (hasFluidValue(source)) {\r\n        removeFluidObserver(source, this);\r\n      }\r\n    });\r\n    this._active.clear();\r\n    becomeIdle(this);\r\n  }\r\n  eventObserved(event) {\r\n    if (event.type == \"change\") {\r\n      if (event.idle) {\r\n        this.advance();\r\n      } else {\r\n        this._active.add(event.parent);\r\n        this._start();\r\n      }\r\n    } else if (event.type == \"idle\") {\r\n      this._active.delete(event.parent);\r\n    } else if (event.type == \"priority\") {\r\n      this.priority = toArray(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);\r\n    }\r\n  }\r\n}\r\nfunction isIdle(source) {\r\n  return source.idle !== false;\r\n}\r\nfunction checkIdle(active) {\r\n  return !active.size || Array.from(active).every(isIdle);\r\n}\r\nfunction becomeIdle(self) {\r\n  if (!self.idle) {\r\n    self.idle = true;\r\n    each(getPayload(self), (node) => {\r\n      node.done = true;\r\n    });\r\n    callFluidObservers(self, {\r\n      type: \"idle\",\r\n      parent: self\r\n    });\r\n  }\r\n}\r\n\r\nconst to = (source, ...args) => new Interpolation(source, args);\r\nconst interpolate = (source, ...args) => (deprecateInterpolate(), new Interpolation(source, args));\r\n\r\nGlobals.assign({\r\n  createStringInterpolator,\r\n  to: (source, args) => new Interpolation(source, args)\r\n});\r\nconst update = frameLoop.advance;\r\n\r\nexport { BailSignal, Controller, FrameValue, Interpolation, Spring, SpringContext, SpringRef, SpringValue, Trail, Transition, config, inferTo, interpolate, to, update, useChain, useSpring, useSpringRef, useSprings, useTrail, useTransition };\r\n//# sourceMappingURL=index.js.map\r\n"]},"metadata":{},"sourceType":"module"}